# Основы Python

## **Class**

Класс в Python — это шаблон для создания объектов. Объекты класса содержат данные и функции, которые работают с этими данными.

**Пример**:
```python
class Автомобиль:
    def __init__(self, марка, модель):
        self.марка = марка
        self.модель = модель

    def отобразить_информацию(self):
        print(f"Марка автомобиля: {self.марка}, Модель: {self.модель}")
```


## **Классметод (Class Method)**:
Метод класса привязан к самому классу, а не к экземпляру класса. Он может изменять состояние класса, которое будет применяться ко всем экземплярам класса. Они определяются внутри класса и требуют декоратора `@classmethod`. Первым аргументом классметода всегда является ссылка на сам класс, обычно обозначаемая как `cls`.

Классметоды могут быть использованы для следующих целей:
- Создание экземпляров класса с использованием различных параметров, отличных от тех, что предусмотрены в конструкторе `__init__`.
- Определение функций, которые логически связаны с классом, но не требуют создания экземпляра класса для выполнения.

**Пример классметода**:
```python
class Автомобиль:
    количество_автомобилей = 0

    def __init__(self, марка, модель):
        self.марка = марка
        self.модель = модель
        Автомобиль.количество_автомобилей += 1

    @classmethod
    def общее_количество_автомобилей(cls):
        return cls.количество_автомобилей
```

В этом примере `общее_количество_автомобилей` является классметодом, который возвращает значение статической переменной `количество_автомобилей`, принадлежащей классу `Автомобиль`. Этот метод может быть вызван напрямую через класс, без необходимости создания экземпляра:

```python
print(Автомобиль.общее_количество_автомобилей())  # Выведет количество созданных автомобилей
```

Классметоды часто используются для реализации фабричных методов, которые создают объекты на основе различных параметров:

```python
class Автомобиль:
    def __init__(self, марка, модель):
        self.марка = марка
        self.модель = модель

    @classmethod
    def от_вин(cls, вин):
        марка = получить_марку_из_вин(вин)  # Предположим, что эта функция определена где-то еще
        модель = получить_модель_из_вин(вин)  # И эта функция тоже
        return cls(марка, модель)
```

Здесь `от_вин` — это классметод, который позволяет создать экземпляр `Автомобиль`, используя VIN-код для определения марки и модели автомобиля.

## **Статикметод (Static Method)**:

Статические методы в Python — это методы, которые можно вызывать без создания экземпляра класса. Они не имеют доступа к экземпляру (`self`) или классу (`cls`), с которыми они связаны. Статические методы определяются внутри класса и используют декоратор `@staticmethod`.

Статические методы полезны, когда вам нужно выполнить какое-то действие, которое связано с классом, но не требует доступа к его экземплярам или самому классу. Они часто используются для группировки утилитных функций в классе.

**Пример статического метода**:
```python
class Автомобиль:
    @staticmethod
    def проверить_валидность_вин(вин):
        return len(вин) == 17 и вин.isdigit()

# Вызов статического метода
print(Автомобиль.проверить_валидность_вин('12345678901234567'))  # Выведет True или False
```

В этом примере `проверить_валидность_вин` является статическим методом, который проверяет, соответствует ли VIN-код определенным критериям (в данном случае длине и состоит ли он только из цифр).

Статические методы могут быть вызваны напрямую через класс, как показано в примере выше, и они не требуют создания экземпляра класса для их использования. Это делает их похожими на обычные функции, но с тем отличием, что они логически связаны с классом, в котором они определены.

## **Проперти (Property)**:
Свойство в Python позволяет использовать методы класса как атрибуты, обеспечивая при этом дополнительную логику, такую как проверка валидности данных.

**Пример**:
```python
class Автомобиль:
    def __init__(self, марка):
        self._марка = марка

    @property
    def марка(self):
        return self._марка

    @марка.setter
    def марка(self, значение):
        if значение != "":
            self._марка = значение
        else:
            raise ValueError("Марка не может быть пустой")
```

Декоратор `@property` в Python используется для создания свойств в классе. Свойства позволяют классам иметь атрибуты, доступ к которым контролируется методами класса, что делает их похожими на геттеры и сеттеры в других языках программирования.

С помощью `@property` можно определить метод, который будет доступен как атрибут только для чтения. Если вы хотите разрешить изменение значения свойства, вы можете определить сеттер с тем же именем, используя декоратор `@<property_name>.setter`.

**Пример использования `@property`**:
```python
class Автомобиль:
    def __init__(self, марка, модель):
        self._марка = марка
        self._модель = модель

    @property
    def марка(self):
        return self._марка

    @марка.setter
    def марка(self, значение):
        self._марка = значение

    @property
    def модель(self):
        return self._модель

# Создание объекта и использование свойств
авто = Автомобиль('Toyota', 'Corolla')
print(авто.марка)  # Выведет 'Toyota'
авто.марка = 'Honda'  # Изменит марку автомобиля на 'Honda'
print(авто.марка)  # Выведет 'Honda'
```

В этом примере `марка` и `модель` являются свойствами класса `Автомобиль`. Метод `марка` определен как свойство с помощью декоратора `@property`, что позволяет получать значение марки автомобиля. С помощью `@марка.setter` определен сеттер, который позволяет изменять марку автомобиля.

Свойства полезны для инкапсуляции данных, предоставления удобного интерфейса для доступа к атрибутам класса и добавления дополнительной логики при получении или установке значения атрибута.

В контексте автоматизации тестирования веб-приложений, `@property` часто используется в паттерне Page Factory для создания свойств, которые представляют элементы на веб-страницах. 

__Page Factory__ — это способ оптимизации процесса автоматизации, который позволяет легко и удобно находить элементы на странице и работать с ними.

Использование `@property` в Page Factory обеспечивает лучшую читаемость кода и позволяет инкапсулировать логику поиска элементов, делая тесты более устойчивыми к изменениям в структуре веб-страницы.

**Пример использования `@property` в Page Factory**:
```python
from selenium.webdriver.support.page_object import PageObject
from selenium.webdriver.common.by import By

class LoginPage(PageObject):
    _username_locator = (By.ID, 'username')
    _password_locator = (By.ID, 'password')
    _login_button_locator = (By.ID, 'loginButton')

    @property
    def username_field(self):
        return self.find_element(*self._username_locator)

    @property
    def password_field(self):
        return self.find_element(*self._password_locator)

    @property
    def login_button(self):
        return self.find_element(*self._login_button_locator)

    def login(self, username, password):
        self.username_field.send_keys(username)
        self.password_field.send_keys(password)
        self.login_button.click()
```

В этом примере `LoginPage` представляет страницу входа в систему. С помощью `@property` создаются свойства `username_field`, `password_field` и `login_button`, которые возвращают элементы веб-страницы. Эти свойства затем используются в методе `login`, который выполняет действия входа в систему.


##  **Дандерные методы (Dunder Methods)**:

Дандерные методы (или магические методы) в Python — это специальные методы, имена которых начинаются и заканчиваются двойным подчеркиванием, например `__init__` или `__str__`. Они предоставляют способ реализации поведения объектов, которое не может быть представлено обычными методами. Вот некоторые из наиболее часто используемых дандерных методов:

- `__init__(self, ...)`: Используется для инициализации нового объекта с начальным состоянием.
- `__del__(self)`: Вызывается при удалении объекта с целью выполнения очистки.
- `__repr__(self)`: Предоставляет официальное строковое представление объекта, которое можно использовать для воссоздания этого объекта.
- `__str__(self)`: Предоставляет более читаемое строковое представление объекта, предназначенное для конечного пользователя.
- `__call__(self, ...)`: Позволяет объекту быть вызванным как функция.
- `__getattr__(self, name)`: Вызывается, когда атрибут не найден в обычных местах.
- `__setattr__(self, name, value)`: Назначает значение атрибуту.
- `__delattr__(self, name)`: Удаляет атрибут.
- `__getitem__(self, key)`: Позволяет объекту использовать синтаксис индексации.
- `__setitem__(self, key, value)`: Назначает значение по индексу или ключу.
- `__delitem__(self, key)`: Удаляет элемент по индексу или ключу.
- `__iter__(self)`: Возвращает итератор для объекта.
- `__next__(self)`: Возвращает следующий элемент в итерации.
- `__contains__(self, item)`: Проверяет наличие элемента в объекте.
- `__eq__(self, other)`: Определяет поведение оператора равенства `==`.
- `__ne__(self, other)`: Определяет поведение оператора неравенства `!=`.
- `__lt__(self, other)`: Определяет поведение оператора `<`.
- `__le__(self, other)`: Определяет поведение оператора `<=`.
- `__gt__(self, other)`: Определяет поведение оператора `>`.
- `__ge__(self, other)`: Определяет поведение оператора `>=`.

Дандерные методы позволяют использовать встроенные функции Python и операторы с пользовательскими объектами, обеспечивая интуитивно понятный и единообразный интерфейс. Например, реализация `__str__` позволяет использовать функцию `print()` для вывода информации об объекте, а `__getitem__` и `__setitem__` позволяют объекту вести себя как коллекция, доступ к элементам которой осуществляется с помощью синтаксиса квадратных скобок.



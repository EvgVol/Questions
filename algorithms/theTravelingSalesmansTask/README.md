# Задача коммивояжера

Это хорошо известная задача, придуманная в качестве своего рода вызова в 1930-х годах. Она относится к классу NP-трудных задач. 

Для начала мы можем случайным образом сгенерировать маршрут, отвечающий условию посещения всех городов, не заботясь об оптимальном решении. 
Затем будем работать над улучшением решения на каждой итерации. Каждый маршрут, сгенерированный в итерации, называется вариантом решения (или сертификатом). 
Доказательство того, что сертификат является оптимальным, требует экспоненциально возрастающего количества времени. Вместо этого будем использовать различные решения на 
основе эвристики, которые генерируют маршруты, близкие к оптимальным, но не оптимальные.
Чтобы выполнить работу, коммивояжеру необходимо посетить определенный список городов:

| Операция       |   |
| :--------------|:---------------------|
| ВВОД           | Список из n городов (обозначается как V) и расстояний между каждой парой городов, d ij (1 ≤ i, j ≤ n)                |
| ВЫВОД          | Кратчайший маршрут, который включает в себя каждый город ровно один раз и завершается в исходном городе                 |


Обратите внимание:
- Расстояния между городами в списке известны.
- Каждый город в данном списке необходимо посетить только один раз.

|          | Оттава  | Монреаль| Кингстон| Торонто | Садбери |
| :--------|:--------| :-------|:--------|:--------|:--------|
| Оттава   | 0       | 199     | 196     | 450     | 484     |
| Монреаль | 199     | 0       | 287     | 542     | 680     |
| Кингстон | 196     | 287     | 0       | 263     | 634     |
| Торонто  | 450     | 542     | 263     | 0       | 400     |
| Садбери  | 484     | 680     | 634     | 400     | 0       |


Обратите внимание, что цель состоит в разработке маршрута, который начинается и заканчивается в исходном городе. 

Например, типичным маршрутом может быть Оттава — Садбери — Монреаль — Кингстон — Торонто — Оттава с общей длиной пути 484 + 680 + 287 + 263 + 450 = 2164. 

*Является ли он маршрутом‚ при котором продавец преодолеет минимальное расстояние? *
*Каким будет оптимальное решение, позволяющее свести к минимуму общее расстояние, пройденное коммивояжером? *


## Использование стратегии полного перебора

Первое решение, которое приходит на ум для задачи TSP, — это использовать полный перебор (`brute force`, иначе называемый `«метод грубой силы»`) и попытаться найти кратчайший путь, при котором коммивояжер посетит каждый город ровно один раз и вернется в исходный город.

Итак, стратегия полного перебора работает следующим образом:
1. Рассчитать все возможные маршруты.
2. Выбрать среди них кратчайший маршрут.

Проблема в том, что для n числа городов существует (n – 1)! возможных маршрутов. Это означает, что пять городов дадут 4! = 24 маршрута и мы выберем самый короткий из них. Очевидно, что такой метод сработает лишь потому, что у нас не так много городов. По мере увеличения числа городов полный перебор превращается в неустойчивую стратегию из-за большого количества перестановок, генерируемых этим методом.

Прежде всего обратим внимание, что маршрут {1, 2, 3} представляет собой маршрут из города 1 в город 2 и город 3.

Общее расстояние — это все расстояние, пройденное за маршрут. Мы будем считать, что расстояние между городами является кратчайшим, то есть евклидовым.

Определим три служебные функции:
- distance_points. Вычисляет абсолютное расстояние между двумя точками;
- distance_tour. Вычисляет общее расстояние, которое коммивояжер должен преодолеть на данном маршруте;
- generate_cities. Случайным образом генерирует набор из n городов, расположенных в прямоугольнике шириной 500 и высотой 300.

Давайте рассмотрим следующий код:

```python
import random
from itertools import permutations


alltours = permutations

def distance_tour(aTour):
    return sum(distance_points(aTour[i - 1], aTour[i]) for i in range(len(aTour)))

aCity = complex

def distance_points(first, second):
    return abs(first - second)

def generate_cities(number_of_cities):
    seed=111;width=500;height=300
    random.seed((number_of_cities, seed))
    return frozenset(aCity(random.randint(1, width), random.randint(1,height)) for c in range(number_of_cities))
```

В предыдущем коде мы применили alltours из функции permutations пакета itertools. 

Мы также представили расстояние комплексным числом. Это означает следующее:
- вычисление расстояния между двумя городами a и b сводится к distance (a,b);
- мы можем создать n-число городов, просто вызвав generate_cities(n).

Теперь давайте определим функцию brute_force, которая генерирует все возможные маршруты через эти города.
Как только она их сгенерирует, будет выбран маршрут с наименьшим расстоянием:

```python
def brute_force(cities):
    "Создать все возможные маршруты по городам и выбрать самый короткий."
    return shortest_tour(alltours(cities))

def shortest_tour(tours):
    return min(tours, key=distance_tour)
```



### Использование жадного алгоритма

Если для решения TSP мы используем жадный алгоритм, то на каждом шаге можем выбрать город, который выглядит приемлемым вариантом, вместо того 
чтобы искать идеальное решение. Поэтому всякий раз, когда нам нужно выбрать город, мы просто выбираем ближайший, не утруждая себя проверкой того, является ли этот выбор глобально оптимальным.

Стратегия жадного алгоритма проста:
1. Начать с любого города.
2. На каждом этапе продолжать строить маршрут, перемещаясь в следующий 
ближайший непосещенный город.
3. Повторить шаг 2.

Определим функцию с именем greedy_algorithm, которая реализует эту логику:
```python
def greedy_algorithm(cities, start=None):
    C = start or first(cities)
    tour = [C]
    unvisited = set(cities - {C})
    while unvisited:
        C = nearest_neighbor(C, unvisited)
        tour.append(C)
        unvisited.remove(C)
    return tour

def first(collection):
    return next(iter(collection))

def nearest_neighbor(A, cities):
    return min(cities, key=lambda C: distance_points(C, A))
```
Теперь используем greedy_algorithm для создания маршрута по 2000 городам.

Обратите внимание, что для создания маршрута по 2000 городам потребовалось всего 0,514 секунды. 

Если бы мы использовали стратегию полного перебора, мы получили бы (2000 – 1)! перестановок, то есть почти бесконечное количество.

Жадный алгоритм основан на эвристике, и нет никаких доказательств того, что решение будет оптимальным.

# Алгоритмы

* Алгоритм — это математическое решение реальной проблемы.

*Согласно словарю `American Heritage Dictionary`:*

    Алгоритм — это конечный набор однозначных инструкций, которые при заданном наборе начальных условий могут выполняться в заданной последовательности для достижения определенной цели и имеют определимый набор конечных условий.


* Разработка алгоритма — это создание набора математических правил для эффективного решения реальной практической задачи. На основе такого набора правил можно создать более общее математическое решение, многократно применимое к широкому спектру аналогичных задач.

Существует различные виды алгоритмов:

1. Алгоритмы [сортировки](sortAlgorithms/README.md)
2. Алгоритмы [поиска](searchAlgorithms/README.md)

## ЭТАПЫ АЛГОРИТМА:

- Проектирование

    *Этап проектирования — это итеративный процесс, который включает в себя сравнение различных потенциально пригодных алгоритмов*

- Кодирование

    *Процесс превращение разработанного алгоритма в компьютерную программу*

## ОПРЕДЕЛЕНИЕ ЛОГИКИ АЛГОРИТМА

* Псевдокод - высокоуровневое неформальное описание алгоритма

Последовательность шагов этапов разработки алгоритмов: 

Постановка задачи -->  Описание шагов -> `ПСЕВДОКОД` -> Кодирование --> ...


## Параметры данных

- Объем (Volume). Ожидаемый размер данных, которые будет обрабатывать алгоритм.
- Скорость (Velocity). Ожидаемая скорость генерации новых данных при использовании алгоритма. Она может быть равна нулю.
- Разнообразие (Variety). Количество различных типов данных, с которым, как ожидается, будет работать алгоритм


## АНАЛИЗ ПРОИЗВОДИТЕЛЬНОСТИ

Анализ производительности алгоритма — важная часть его разработки‚ и одним из способов такой оценки выступает анализ сложности алгоритма.


Теория сложности — это изучение того, насколько сложны алгоритмы. Чтобы быть полезным, алгоритму необходимо обладать тремя ключевыми функциями:
- Он должен быть верным. От алгоритма мало пользы, если он не дает правильных ответов.
- Хороший алгоритм должен быть понятным для компьютера. Лучший алгоритм в мире окажется бесполезным, если его слишком сложно реализовать.
- Хороший алгоритм должен быть эффективным. Невозможно использовать алгоритм, который даст правильный результат, но при этом на его работу уйдет тысяча лет или потребуется 1 миллиард терабайт памяти.

Существуют два типа анализа для количественной оценки сложности алгоритма:
- Анализ пространственной сложности (space complexity analysis) — оценка требований к памяти во время выполнения алгоритма.
- Анализ временной сложности (time complexity analysis) — оценка времени, необходимого для выполнения алгоритма


## Основные концепции разработки алгоритма

Разработка алгоритма заключается в том, чтобы придумать этот «конечный набор однозначных инструкций»‚ позволяющий наиболее эффективным способом добиться «достижения определенной цели».

В случае сложной прикладной задачи разработка алгоритма — дело весьма утомительное. 

Чтобы осуществить качественную реализацию, мы должны всесторонне изучить поставленную задачу. Прежде чем придумать, как это будет сделано (то есть 
разработать алгоритм)‚ необходимо выяснить, что нужно сделать (то есть понять требования). 

Понимание задачи включает в себя как функциональные, так и нефункциональные требования. Давайте посмотрим, что это такое:
- Функциональные требования формально определяют интерфейсы ввода и вывода, а также связанные с ними функции. Они помогают понять, как 
данные будут обрабатываться и какие вычисления необходимо реализовать, чтобы получить результат.

- Нефункциональные требования определяют ожидания в отношении производительности и безопасности алгоритма.

Разработка алгоритма подразумевает удовлетворение как функциональных, так и нефункциональных требований наилучшим возможным способом, учитывая 
обстоятельства и доступные ресурсы.

Чтобы получить результат, соответствующий функциональным и нефункциональным требованиям, надо ответить на три вопроса:
- Вопрос 1. *Даст ли разработанный алгоритм ожидаемый результат?*
- Вопрос 2. *Является ли данный алгоритм оптимальным способом получения этого результата?*
- Вопрос 3. *Как алгоритм будет работать с большими наборами данных?*


### Вопрос 1. Даст ли разработанный алгоритм ожидаемый результат?

О проверке правильности алгоритма нужно думать заранее‚ и она должна быть заложена в его архитектуру. Прежде чем разрабатывать стратегию проверки алгоритма, нам нужно рассмотреть 
следующие два аспекта:

- Определение истины (truth). 

Для проверки алгоритма нам нужны некоторые известные правильные результаты для заданного набора входных данных. 
В контексте поставленной задачи такие результаты называются истинами. Пытаясь найти лучшее решение, мы последовательно совершенствуем наш алгоритм и используем истину в качестве ориентира.

- Выбор метрик.

Кроме того, нужно решить, как именно мы собираемся количественно оценивать отклонение от определенной истины. Выбор правильных 
показателей (метрик) поможет точно оценить качество нашего алгоритма.

Например, для алгоритмов машинного обучения в качестве истины можно использовать существующие размеченные данные. Для количественной оценки 
отклонения от истины можно выбрать одну или несколько метрик, таких как доля правильных ответов (accuracy), полнота (recall) или точность (precision). 
Важно отметить, что в некоторых случаях результат не ограничен одним значением‚ а представляет собой диапазон для заданного набора входных данных. 
Во время разработки нашей целью будет итеративное улучшение алгоритма до тех пор, пока результат не окажется в пределах диапазона, указанного в требованиях.

### Вопрос 2. Является ли данный алгоритм оптимальным способом получения результата?

Понимание задачи и ее сложности — важно, и это помогает оценить требования к ресурсам.

Прежде чем мы углубимся в детали, давайте определим два термина.

- Полиномиальный алгоритм (polynomial algorithm).
Если алгоритм имеет временную сложность O(n^k), мы называем его полиномиальным, где k — константа.

- Сертификат (certificate). 
Предлагаемый вариант решения, полученный по окончании итерации, называется сертификатом. По мере итеративного продвижения к решению конкретной задачи мы обычно генерируем серию сертификатов. Если решение стремится к сходимости, каждый сгенерированный сертификат будет лучше предыдущего. В какой-то момент, когда сертификат будет соответствовать требованиям, мы выберем его в качестве окончательного решения.

#### Определение сложности задачи

Прежде чем разрабатывать решение, имеет смысл охарактеризовать задачу.

 Как правило, задачи делятся на три типа:
- Тип 1. Задачи, для которых доказано существование полиномиального алгоритма;
- Тип 2. Задачи, для которых доказано, что они не могут быть решены с помощью полиномиального алгоритма;
- Тип 3. Задачи, для которых не найден полиномиальный алгоритм, но не доказано, что его не существует.

Существует различные классы задач:
1. Недетерминированные полиномиальные, `NP (non-deterministic polynomial)`.

Чтобы задача была NP-задачей, она должна удовлетворять следующему условию:
```bash
Гарантированно существует полиномиальный алгоритм, который может быть использован для проверки оптимальности варианта решения (сертификата).
```

2. Полиномиальные, `P (polynominal)`. 
Это типы задач, которые можно рассматривать как подмножество `NP`. 

В дополнение к выполнению условия задачи `NP` задачи `P` должны удовлетворять еще одному условию:
```bash
Гарантированно существует по крайней мере один полиномиальный алгоритм, который может быть использован для их решения.
```

3. NP-полные (NP-complete). 

Данная категория содержит самые сложные задачи из всех NP. 

NP-полная задача удовлетворяет следующим двум условиям:
- не существует известных полиномиальных алгоритмов для генерации сертификата;
- существуют известные полиномиальные алгоритмы для проверки того, что предлагаемый сертификат является оптимальным.

4. NP-трудные (NP-hard). 

Эта категория содержит задачи, которые по крайней мере так же сложны, как и любая задача категории NP; при этом они необязательно принадлежат категории NP.


### Вопрос 3. Как алгоритм будет работать с большими наборами данных?

Чтобы количественно оценить масштабируемость алгоритма, необходимо учитывать следующие два аспекта:
- Увеличение потребностей в ресурсах по мере роста объема входных данных. 
Оценка такого требования называется анализом пространственной сложности.
- Увеличение времени, затрачиваемого на выполнение, по мере роста объема входных данных. 
Оценка данного параметра называется анализом временной сложности.


## «О-большое»

### Константная временная сложность (O(1))

Если выполнение алгоритма занимает одинаковое количество времени независимо от размера входных данных, то про него говорят, что он выполняется постоянное время. Такая сложность обозначается как O(1). В качестве примера рассмотрим доступ к n-му элементу массива. Независимо от размера массива для получения результата потребуется одно и то же время.

Например, следующая функция вернет первый элемент массива (ее сложность O(1)):

```bash
>>> def getFirst(myList):
        return myList[0]
```

- Добавление нового элемента в стек с помощью push или удаление элемента из стека с помощью pop. Независимо от размера стека добавление или удаление элемента займет одно и то же время.

- Доступ к элементу хеш-таблицы.
- Блочная (иначе называемая корзинная или карманная) сортировка (Bucket sort).


### Линейная временная сложность (O(n))

Считается, что алгоритм имеет линейную временную сложность, обозначаемую O(n), если время выполнения прямо пропорционально размеру входных данных. 

Простой пример — добавление элементов в одномерную структуру данных:

```python
>>> def getSum(myList):
        sum = 0
        for item in myList:
            sum = sum + item
        return sum
```

Ниже приведены некоторые другие примеры операций с массивами:
- Поиск элемента.
- Нахождение минимального значения среди всех элементов массива.

### Квадратичная временная сложность (O(n^2))

Считается, что алгоритм выполняется за квадратичное время, если время выполнения алгоритма пропорционально квадрату размера входных данных. Например, простая функция, которая суммирует двумерный массив, выглядит следующим образом:

```python
>>> def getSum(myList):
        sum = 0
        for row in myList:
            for item in row:
                sum += item
        return sum
```

Другим примером квадратичной временной сложности является алгоритм сортировки пузырьком.


### Логарифмическая временная сложность (O(logn))

Считается, что алгоритм выполняется за логарифмическое время, если время выполнения алгоритма пропорционально логарифму размера входных данных. С каждой итерацией размер входных данных уменьшается в несколько раз. 

римером логарифмической временной сложности является бинарный поиск. 

Алгоритм бинарного поиска используется для поиска определенного элемента в одномерной структуре данных, такой как список в Python. Элементы в структуре данных должны быть отсортированы в порядке убывания. Алгоритм бинарного поиска реализован в функции с именем searchBinary следующим образом:


```python
>>> def searchBinary(myList, item):
        first = 0
        last = len(myList)-1
        foundFlag = False
        while (first<=last and not foundFlag):
            mid = (first + last)//2
            if myList[mid] == item :
                foundFlag = True
            else:
                if item < myList[mid]:
                    last = mid - 1
                else:
                    first = mid + 1
        return foundFlag
```

Алгоритм бинарного поиска использует технику, называемую «разделяй и властвуй». Эту же технику использует алгоритм сортировки слиянием.

Метод «разделяй и властвуй» работает следующим образом:

1. Алгоритм разбивает список на левую и правую части, разделенные серединным элементом.
2. Для хранения искомого значения создается переменная.
3. Алгоритм выбирает серединный элемент и сравнивает его с искомым значением.
4. Если сравниваемые элементы равны, то процесс завершается.
5. В противном случае серединный элемент либо больше, либо меньше искомого значения. Если он больше, дальнейший поиск происходит в левой части списка. Если серединный элемент меньше искомого, дальше поиск идет в правой части списка.

## ПРОВЕРКА АЛГОРИТМА

### Точные, приближенные и рандомизированные алгоритмы

Алгоритмы делятся на два типа:
- Точный алгоритм (exact algorithm). Ожидается, что такой алгоритм даст точное решение без каких-либо допущений или приближений.
- Приближенный алгоритм (approximate algorithm). Когда сложность задачи слишком велика для имеющихся ресурсов, мы упрощаем нашу задачу, делая допущения. Алгоритмы, основанные на этих упрощениях или допущениях, называются приближенными алгоритмами и дают не совсем точное решение.


## СТРУКТУРЫ ДАННЫХ В PYTHON

В Python существуют пять различных структур данных для хранения коллекций:
- Список (List). Упорядоченная изменяемая последовательность элементов.
- Кортеж (Tuple). Упорядоченная неизменяемая последовательность элементов.
- Множество (Set). Неупорядоченная последовательность элементов.
- Словарь (Dictionary). Неупорядоченная последовательность пар «ключ — значение».
- DataFrame. Двумерная структура для хранения двумерных данных.

## 1. Список

* Cписок — это основная структура данных, используемая для хранения изменяемой последовательности элементов.

- Индексация списка. Поскольку положение каждого элемента в списке детерминировано, к нему можно получить доступ с помощью индекса. 

Следующий код демонстрирует этот принцип:
```python
>>> bin_colors=['Red','Green','Blue','Yellow']
>>> bin_colors[1]
# 'Green'
```

- Срез списка. Извлечение подмножества элементов списка путем указания диапазона индексов называется срезом.

Пример кода среза:
```python
>>> bin_colors=['Red','Green','Blue','Yellow']
>>> bin_colors[0:2]
# ['Red', 'Green']
```

- Отрицательная индексация. В Python имеются и отрицательные индексы, которые отсчитываются от конца списка.

Это показано в следующем коде:
```python
>>> bin_colors=['Red','Green','Blue','Yellow']
>>> bin_colors[:-1]
# ['Red', 'Green', 'Blue']
>>> bin_colors[:-2]
# ['Red', 'Green']
>>> bin_colors[-2:-1]
# ['Blue']
```

- Вложенность. Элемент списка может относиться к простому или сложному типу данных. Это позволяет создавать вложенные списки и дает возможность 
использовать потенциал итеративных и рекурсивных алгоритмов.

Рассмотрим пример списка внутри списка (вложенность):
```python
>>> a = [1,2,[100,200,300],6]
>>> max(a[2])
# 300
>>> a[2][1]
# 200
```

- Итерация. Python позволяет выполнять итерацию для каждого элемента в списке с помощью цикла for.
Это показано в следующем примере:
```python
>>> bin_colors=['Red','Green','Blue','Yellow']
>>> for aColor in bin_colors:
        print(aColor + " Square")
# Red Square
# Green Square
# Blue Square
# Yellow Square
```

### Лямбда-функции

Существует множество лямбда-функций, которые можно использовать в списках. 
Они особенно полезны в работе с алгоритмами и позволяют создавать функцию 
на лету. Иногда в литературе их также называют анонимными функциями. 

Рассмотрим их применение:

- Фильтрация данных. Для фильтрации данных мы должны определить предикат — функцию, которая тестирует каждый аргумент и возвращает логическое значение.

Пример использования такой функции:
```python
>>> list(filter(lambda x: x > 100, [-5, 200, 300, -10, 10, 1000])) 
[200, 300, 1000]
```

- Преобразование данных. Функция map() используется для преобразования данных с помощью лямбда-функции.

Пример:
```python
>>> list(map(lambda x: x ** 2, [11, 22, 33, 44,55]))
# [121, 484, 1089, 1936, 3025]
```

Использование функции `map()` вместе с лямбда-функцией открывает большие возможности. При этом лямбда-функция задает преобразователь, изменяющий 
каждый элемент последовательности. 

В приведенном примере преобразователем выступает возведение во вторую степень.
Таким образом, мы используем функцию `map()` для получения квадрата каждого элемента в списке.


- Агрегирование данных. Для агрегирования данных используется `reduce()`, которая рекурсивно применяет функцию к паре значений для каждого элемента списка:
```python
from functools import reduce
>>> def doSum(x1, x2):
        return x1 + x2
>>> x = reduce(doSum, [100, 122, 33, 4, 5, 6])
# 270
```


### Функция range

С помощью функции `range()` можно легко сгенерировать большой список чисел. 
Она используется для автоматического добавления последовательностей чисел в список


Функцию `range()` очень просто использовать — нужно только указать количество элементов, которые мы хотим видеть в списке.

По умолчанию последовательность начинается с нуля и далее увеличивается с шагом, равным единице:
```python
>>> x = range(6)
>>> x
# [0,1,2,3,4,5]
```

Мы также можем указать конечное число и шаг, например:
```python
>>> oddNum = range(3, 29, 2)
>>> oddNum
# [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27]
```
В результате получим нечетные числа от 3 до 27.

### Временная сложность списков

| Операция            | Временная сложность  |
| :-------------------|:---------------      |
| Вставить элемент    | O(1)                 |
| Удалить элемент     | O(n)                 | 
| Срез списка         | O(n)                 |
| Извлечение элемента | O(n)                 |
| Копирование         | O(n)                 |


## 2. Кортеж

Еще одна структура данных, которую можно использовать для хранения коллекции, — кортеж.
В отличие от списков, кортежи являются неизменяемыми (доступными только для чтения) структурами данных.
Кортежи состоят из нескольких элементов, заключенных в круглые скобки ( )

В данном коде показано, как создавать кортежи:
```python
>>> bin_colors=('Red','Green','Blue','Yellow')
>>> bin_colors[1]
# 'Green'
>>> bin_colors[2:]
# ('Blue', 'Yellow')
>>> bin_colors[:-1]
# ('Red', 'Green', 'Blue')
# Nested Tuple Data structure (вложенный кортеж)
>>> a = (1,2,(100,200,300),6)
>>> max(a[2])
# 300
>>> a[2][1]
# 200
```

### Временная сложность кортежа

| Операция            | Временная сложность  |
| :-------------------|:---------------      |
| Append()            | O(1)                 |


* Append() — это функция, которая добавляет элемент в конец уже существующего кортежа. Ее сложность равна O(1)

## 3. Словарь

Хранение данных в виде пар «ключ — значение» особенно полезно при работе с распределенными алгоритмами.
В Python коллекция пар «ключ — значение» хранится в виде структуры данных, называемой словарем.
Чтобы создать словарь, в качестве атрибута следует выбрать ключ, лучше всего подходящий для идентификации данных во время обработки.
Значением ключа может быть элемент любого типа, например число или строка.
В Python в качестве значений также используются сложные типы данных, например списки.
Если использовать в качестве значения ключа словарь, можно создавать вложенные словари

```python
>>> bin_colors ={
        "manual_color": "Yellow",
        "approved_color": "Green",
        "refused_color": "Red"
    }
>>> print(bin_colors)
# {'manual_color': 'Yellow', 'approved_color': 'Green', 'refused_color': 'Red'}
```

### Временная сложность словаря

| Операция                      | Временная сложность  |
| :-----------------------------|:---------------      |
| Получить значение или ключ    | O(1)                 |
| Установить значение или ключ  | O(1)                 | 
| Скопировать словарь           | O(n)                 |


## 4. Множество

* Множество — это коллекция элементов одного или разных типов. Элементы заключены в фигурные скобки { }.

Взгляните на следующий сниппет:
```python
>>> green = {'grass', 'leaves'}
>>> print(green)
# {'grass', 'leaves'}
```

Отличительной особенностью множества является то, что в нем хранится только `уникальное` значение каждого элемента.
Если мы попытаемся добавить дубль, он будет проигнорирован:
```python
>>> green = {'grass', 'leaves','leaves'}
>>> print(green)
# {'grass', 'leaves'}
```

### Временная сложность множества

| Операция                      | Временная сложность  |
| :-----------------------------|:---------------------|
| Добавление элемента           | O(1)                 |
| Удаление элемента             | O(1)                 | 
| Копирование                   | O(n)                 |


## 5. DataFrame

* DataFrame — табличная структура данных, доступная в библиотеке Python pandas.
Это одна из наиболее важных структур данных для алгоритмов. Она используется для обработки классических структурированных данных.
Рассмотрим таблицу:

| id       | name (имя)  | age (возраст) | decision (решение)
| :--------|:------------|:--------------|:------------------|
| 1        | Fares       | 32            | True              |
| 2        | Elena       | 23            | False             |
| 3        | Steven      | 40            | True              |


Теперь представим эту таблицу с помощью DataFrame.

Простейший DataFrame может быть создан с помощью следующего кода:
```python
>>> import pandas as pd
>>> df = pd.DataFrame([
... ['1', 'Fares', 32, True],
... ['2', 'Elena', 23, False],
... ['3', 'Steven', 40, True]])
>>> df.columns = ['id', 'name', 'age', 'decision']
>>> df
# id name age decision
# 0 1 Fares 32 True
# 1 2 Elena 23 False
# 2 3 Steven 40 True
```

### Терминология DataFrame

- Ось. В документации pandas один столбец или строка DataFrame называется осью (axis).
- Метка. DataFrame позволяет отмечать как столбцы, так и строки так называемой меткой (label).

### Создание подмножества DataFrame

```python
>>> df[['name','age']]
# name age
# 0 Fares 32
# 1 Elena 23
# 2 Steven 40
```

Позиция столбца является детерминированной.

Доступ к нему по его расположению можно получить следующим образом:
```python
>>> df.iloc[:,3]
# 0 True
# 1 False
# 2 True
```

## 6. Матрица

* Матрица — это двумерная структура данных с фиксированным количеством столбцов и строк.

В Python матрицу можно создать с помощью массива numpy:
```python
>>> myMatrix = np.array([[11, 12, 13], [21, 22, 23], [31, 32, 33]])
>>> print(myMatrix)
# [[11 12 13]
# [21 22 23]
# [31 32 33]]
>>> print(type(myMatrix))
# <class 'numpy.ndarray'>
```

### Операции с матрицами

Существует множество операций, доступных для матричных данных.
Давайте транспонируем матрицу из предыдущего примера.
Для этого используем функцию `transpose()`, которая преобразует столбцы в строки, а строки в столбцы:
```python
>>> myMatrix.transpose()
#array([[11, 21, 31],
#      [12, 22, 32],
#      [13, 23, 33]])
```
Отметим, что матричные операции часто используются при обработке мультимедийных данных.


## АБСТРАКТНЫЕ ТИПЫ ДАННЫХ

* В широком смысле абстракция — принцип, используемый для определения сложных систем с точки зрения их общих базовых функций.

Применение этой концепции при создании структур данных приводит к появлению абстрактных типов данных (AТД).
Используя АТД, мы получаем универсальную, независимую от реализации структуру данных. 
Это позволяет написать более простой и чистый код алгоритма, не углубляясь в детали разработки. 
АТД ­можно реализовать на любом языке программирования, например C++, Java и Scala.
В этом разделе мы будем использовать АТД в Python. Начнем с `вектора`.

### Вектор

* Вектор — это одномерная структура для хранения данных‚ одна из самых популярных в Python. 

В Python имеются два способа создания векторов.

1. Использование списка Python.

Самый простой способ создания вектора — применить список Python следующим образом:
```python
>>> myVector = [22, 33, 44, 55]
>>> print(myVector)
# [22 33 44 55]
>>> print(type(myVector))
# <class 'list'>
```

2. Использование массива numpy. 

Еще один популярный способ создания вектора — применение массивов NumPy, как показано ниже:
```python
>>> myVector = np.array([22,33,44,55])
>>> print(myVector)
# [22 33 44 55]
>>> print(type(myVector))
# <class 'numpy.ndarray'>
```

### Стек

* Стек — это линейная структура данных для хранения одномерного списка. 

Элементы в стеке могут обрабатываться по принципу `LIFO (Last-In, First-Out: «последним пришел — первым ушел»)`
либо по принципу `FILO (First-In, Last-Out: «первым пришел — последним ушел»)`. 

Порядок добавления и удаления элементов определяет характер стека.
Новые элементы могут добавляться и удаляться только с одного конца списка.

Ниже приведены операции со стеками:
- isEmpty. Возвращает true, если стек пуст;
- push. Добавляет новый элемент;
- pop. Возвращает элемент, добавленный последним, и удаляет его.

Давайте создадим класс с именем Stack‚ в котором опишем все операции, связанные с классом stack.
Код этого класса будет выглядеть следующим образом:

```python
class Stack:

    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()
    
    def peek(self):
        return self.items[len(self.items) - 1]

    def size(self):
        return len(self.items)

``` 

### Временная сложность стека

| Операция       | Временная сложность  |
| :--------------|:---------------------|
| push           | O(1)                 |
| pop            | O(1)                 | 
| size           | O(1)                 |
| peek           | O(1)                 |


### Очередь


Как и стек, очередь хранит n элементов в одномерной структуре. 
Элементы добавляются и удаляются по принципу `FIFO (First-In, First-Out: «первым пришел — первым ушел»)`. 

Каждая очередь имеет начало и конец. Когда элементы удаляются из начала, операция называется удалением из очереди — `dequeue`. 
Когда элементы добавляются в конец, операция называется постановкой в очередь — `enqueue`.


Очередь может быть реализована с помощью следующего кода:

```python
class Queue(object):

    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)
``` 


### Дерево

* Дерево — иерархическая структура данных, что делает ее особенно полезной при разработке алгоритмов.

Мы используем деревья везде, где требуются иерархические отношения между элементами данных.


Каждое дерево имеет конечный набор узлов, так что в нем есть начальный элемент данных, называемый корнем (root), и набор узлов, соединенных между собой ветвями (branches).


- Типы деревьев:

* Двоичное дерево (binary tree). Если степень дерева равна двум, оно называется двоичным.
* Полное дерево (full tree). Это дерево, в котором все узлы имеют одинаковую степень, которая равна степени дерева.
* Идеальное дерево (perfect tree). Это особый тип полного дерева, у которого все конечные узлы расположены на одном уровне. 
* Упорядоченное дерево (ordered tree). Если дочерние элементы узла организованы в определенном порядке согласно установленным критериям, дерево называется упорядоченным.
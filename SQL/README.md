# SQL (Structured Query Language)

## Оглавление

0. [Основные принципы реляционных баз данных](#основные-принципы-реляционных-баз-данных)
1. [Терминология реляционных баз данных](#терминология-реляционных-баз-данных)
2. [Отношение, реляционная модель](#основные-принципы-реляционных-баз-данных)
3. [Выбор типов данных для полей](#выбор-типов-данных-для-полей)
4. [Выборка данных](#выборка-данных)
    1. [Выборка данных, вычисляемые столбцы, математические функции](#выборка-данных-вычисляемые-столбцы-математические-функции)
    2. [Выборка данных, вычисляемые столбцы, логические функции](#выборка-данных-вычисляемые-столбцы-логические-функции)
    3. [Выборка данных по условию](#выборка-данных-по-условию)
    4. [Выборка данных, логические операции](#выборка-данных-логические-операции)
    5. [Выборка данных, операторы BETWEEN, IN](#выборка-данных-операторы-between-in)
    6. [Выборка данных с сортировкой](#выборка-данных-с-сортировкой)
    7. [Выборка данных, оператор LIKE](#выборка-данных-оператор-like)
    8. [Выборка данных, оператор LIMIT](#выборка-данных-оператор-limit)
5. [Запросы, групповые операции](#запросы-групповые-операции)
    1. [Выборка уникальных элементов столбца](#выборка-уникальных-элементов-столбца)
    2. [Выборка данных (групповые функции sum и count)](#выборка-данных-групповые-функции-sum-и-count)
    3. [Выборка данных (групповые функции min, max и avg)](#выборка-данных-групповые-функции-min-max-и-avg)
    4. [Выборка данных с вычислением (групповые функции)](#выборка-данных-с-вычислением-групповые-функции)
    5. [Вычисление по таблице целиком](#вычисление-по-таблице-целиком)
    6. [Выборка данных по условию (групповые функции)](#выборка-данных-по-условию-групповые-функции)
    7. [Выборка данных по условию (групповые функции WHERE и HAVING)](#выборка-данных-по-условию-групповые-функции-where-и-having)
6. [Вложенные запросы](#вложенные-запросы)
    1. [Вложенный запрос, возвращающий одно значение](#вложенный-запрос-возвращающий-одно-значение)
    2. [Использование вложенного запроса в выражении](#использование-вложенного-запроса-в-выражении)
    3. [Вложенный запрос, оператор IN](#вложенный-запрос-оператор-in)
    4. [Вложенный запрос, операторы ANY и ALL](#вложенный-запрос-операторы-any-и-all)
    5. [Вложенный запрос после SELECT](#вложенный-запрос-после-select)
6. [Запросы корректировки данных](#запросы-корректировки-данных)
    1. [Создание пустой таблицы](#создание-пустой-таблицы)
    2. [Добавление в таблицу записи как совокупность значений](#добавление-в-таблицу-записи-как-совокупность-значений)
    3. [Добавление записи из другой таблицы](#добавление-записи-из-другой-таблицы)
    4. [Добавление записи из другой таблицы, используя вложенный запрос](#добавление-записи-из-другой-таблицы-используя-вложенный-запрос)
    5. [Изменение значения в одном столбце](#изменение-значения-в-одном-столбце)
    6. [Изменение значения в нескольких столбцах](#изменение-значения-в-нескольких-столбцах)
    7. [Изменение данных, используя несколько таблиц](#изменение-данных-используя-несколько-таблиц)
    8. [Удаление записи из таблицы](#удаление-записи-из-таблицы)
    9. [Создание таблицы на основе данных других таблиц](#создание-таблицы-на-основе-данных-других-таблиц)
7. [Запросы SQL к связанным таблицам](#запросы-sql-к-связанным-таблица)
    1. [Cвязь между таблицами «один ко многим»](#cвязь-между-таблицами-«один-ко-многим»)
    2. [Cвязь между таблицами «многие ко многим»](#cвязь-между-таблицами-«многие-ко-многим»)
    3. [Cоздание таблицы с внешними ключами](#создание-таблицы-на-основе-данных-других-таблиц)
    4. [Действия при удалении записи главной таблицы](#действия-при-удалении-записи-главной-таблицы)
8. [Запросы на выборку, соединение таблиц](#запросы-на-выборку-соединение-таблиц)
    1. [Соединение INNER JOIN](#соединение-inner-join)
    2. [Внешнее соединение LEFT и RIGHT OUTER JOIN](#внешнее-соединение-left-и-right-outer-join)
    3. [Перекрестное соединение CROSS JOIN](#перекрестное-соединение-cross-join)
    4. [Запросы на выборку из нескольких таблиц](#запросы-на-выборку-из-нескольких-таблиц)
    5. [Запросы для нескольких таблиц с группировкой](#запросы-для-нескольких-таблиц-с-группировкой)
    6. [Запросы для нескольких таблиц со вложенными запросами](#запросы-для-нескольких-таблиц-со-вложенными-запросами)
    7. [Вложенные запросы в операторах соединения](#вложенные-запросы-в-операторах-соединения)
    8. [Операция соединение, использование USING()](#операция-соединение-использование-using)
9. [Запросы корректировки, соединение таблиц]()
Запросы корректировки, соединение таблиц
Запросы на обновление, связанные таблицы
Запросы на добавление, связанные таблицы
Запрос на добавление, связанные таблицы
Запрос на обновление, вложенные запросы
Каскадное удаление записей связанных таблиц
Удаление записей главной таблицы с сохранением записей в зависимой
Удаление записей, использование связанных таблиц
10. [Прочие примеры](examples/README.md)


* SQL - это декларативный язык программирования (язык запросов), который используют для создания, обработки и хранения данных в реляционных базах данных.

Реляционная модель была разработана в конце 1960-х годов Е.Ф.Коддом.
Она определяет способ представления данных (структуру данных), методы защиты данных (целостность данных), и операции, которые можно выполнять с данными (манипулирование данными).

Эта модель лежит в основе всех реляционных баз данных до настоящего времени.

## Основные принципы реляционных баз данных:

- все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
- в пересечение строки и столбца таблицы можно занести только одно значение;
- все операции выполняются над целыми отношениями и результатом этих операций является отношение.


## Терминология реляционных баз данных:

* отношение  – это структура данных целиком, набор записей (в обычном понимании – таблица);

* кортеж – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <001, Борин С.А, 234-01-23, программист>, все кортежи в отношении должны быть различны;

* мощность – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;

* атрибут – это столбец в таблице (более распространенный термин – поле);

* размерность – это число атрибутов в таблице;
размерность отношения должна быть больше 0, порядок следования атрибутов существенен;

* домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута Должность домен – {инженер, программист}.

[:arrow_up:Оглавление](#Оглавление)

## Отношение, реляционная модель

База данных, в том числе и реляционная, используется для формального описания некоторой предметной области реального мира, например, склада, учебного процесса и пр. Обязательным этапом перед созданием базы данных является ее проектирование.

Перед созданием таблицы в базе данных необходимо описать ее структуру. Для этого выполняется следующая последовательность шагов:

1. Дать таблице имя, пусть она будет называться `book`, вот некоторые правила для выбора имен таблиц:

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
- имя должно быть уникальным в пределах базы данных.

Также рекомендуется:

- чтобы имя было существительным в единственном числе;
- имя должно быть понятным и соответствовать тому объекту, который оно описывает;
- имя должно быть как можно короче, максимум до 10 символов.

2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять.

Правила по выбору имени поля информационного объекта:

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
- имя поля должно быть уникальным в пределах таблицы.

Рекомендации по выбору имени поля информационного объекта:

- имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;
- имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.

3. Включить ключевое поле `book_id`, которое является `ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ` каждой реляционной таблицы. 
Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.

Рекомендации по именованию  ключевых полей:

- имя должно состоять из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать `id`.

[:arrow_up:Оглавление](#Оглавление)

## Выбор типов данных для полей 

После описания структуры таблицы необходимо выбрать типы данных для каждого поля.

### Основные типы данных SQL:

| Тип данных        | Описание                                       | Пример                            |
| :-----------------| :--------------------------------------------  | :-------------------------------- |
| INT (INTEGER)     | Целое число от -2 147 483 648 до 2 147 483 647 | -5671205                          |
| DECIMAL (NUMERIC) | Вещественное число                             | -3.294                            |
| DATE              | Дата                                           |                                   |
| VARCHAR           |                                                |                                   |

[:arrow_up:Оглавление](#Оглавление)


# Выборка данных

... (пропущено)

## Выборка данных, вычисляемые столбцы, математические функции

| Функция           | Описание                                                | Пример                              |
| :-----------------| :--------------------------------------------           | :--------------------------------   |
| CEILING(x)        | возвращает наименьшее целое число, большее или равное x | CEILING(4.2)=5 CEILING(-5.8)=-5     |
| ROUND(x, k)       | округляет значение x до k знаков после запятой          | ROUND(4.361)=4 ROUND(5.86592,1)=5.9 |
| FLOOR(x)          | возвращает наибольшее целое число, меньшее или равное x | FLOOR(4.2)=4 FLOOR(-5.8)=-6         |
| POWER(x, y)       | возведение x в степень y                                | POWER(3,4)=81.0                     |
| SQRT(x)           | квадратный корень из x                                  | SQRT(4)=2.0 SQRT(2)=1.41...         |
| DEGREES(x)        | конвертирует значение x из радиан в градусы             | DEGREES(3) = 171.8...               |
| RADIANS(x)        | конвертирует значение x из градусов в радианы           | RADIANS(180)=3.14...                |
| ABS(x)            | модуль числа x                                          | ABS(-1) = 1  ABS(1) = 1             |
| PI()              | pi = 3.1415926...                                       |                                     |

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF()`:

```bash
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1, в противном случае –  значение выражения_2.
Все три параметра `IF()` являются `обязательными`.

Допускается использование вложенных функций, вместо выражения_1 или выражения_2 может стоять новая функция `IF`.

<hr>

*ПРИМЕР:*
*При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать new_price. Значение округлить до двух знаков после запятой.*

```sql
SELECT author, title,
    ROUND(IF(author = 'Булгаков М.А.', price * 1.10, IF(author = 'Есенин С.А.', price * 1.05, price)), 2) AS new_price 
FROM book;
```
```sql
Query result:
+------------------+-----------------------+-----------+
| author           | title                 | new_price |
+------------------+-----------------------+-----------+
| Булгаков М.А.    | Мастер и Маргарита    | 738.09    |
| Булгаков М.А.    | Белая гвардия         | 594.55    |
| Достоевский Ф.М. | Идиот                 | 460.00    |
| Достоевский Ф.М. | Братья Карамазовы     | 799.01    |
| Есенин С.А.      | Стихотворения и поэмы | 682.50    |
+------------------+-----------------------+-----------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию.

Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. 

Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

<hr>

*ПРИМЕР:*
*Вывести название и цену тех книг, цены которых меньше 600 рублей.*

```sql
SELECT title, price FROM book WHERE price < 600;
```
```sql
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, логические операции

Логическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

- круглые скобки
- умножение  (*),  деление (/)
- сложение  (+), вычитание (-)
- операторы сравнения (=, >, <, >=, <=, <>)
- NOT
- AND
- OR

<hr>

*ПРИМЕР:*
*Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей*

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```
```sql
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, операторы BETWEEN, IN

Логическое выражение после ключевого слова `WHERE` может включать операторы  `BETWEEN` и `IN`. 
Приоритет у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `NOT`, `AND`, `OR`.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

<hr>

*ПРИМЕР:*
*Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.*

```sql
SELECT title, amount
FROM book
WHERE amount BETWEEN 5 AND 14;
```
```sql
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)


## Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. 
Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. 

При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. 
По умолчанию `ORDER BY` выполняет сортировку по возрастанию. 

Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

- названием столбца;
- номером столбца;
- именем столбца (указанным после AS).

<hr>

*ПРИМЕР:*
*Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.*

```sql
SELECT title, author, price
FROM book
ORDER BY title;
```
```sql
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
```

Аналогичный результат получится при использовании запроса:

```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, оператор LIKE

Оператор `LIKE` используется для сравнения строк. 

В отличие от операторов отношения равно (=) и не равно (<>), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. 

Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. 

Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

| Символ шаблона | Описание                                         | Пример                                      |
| :--------------| :--------------------------------------------    | :--------------------------------           |
| %              | Любая строка, содержащая ноль или более символов | SELECT * FROM book WHERE author LIKE '%М.'  |
| -              | Любой одиночный символ                           | SELECT * FROM book WHERE title LIKE 'Поэм_' |

<hr>

*ПРИМЕР:*
*Вывести названия книг, начинающихся с буквы «Б».*

```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```
```sql
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, оператор LIMIT

Для ограничения вывода записей в SQL используется оператор `LIMIT` , после которого указывается количество строк.
Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`. `LIMIT` размещается после раздела `ORDER BY`.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 

<hr>

*ПРИМЕР:*
*Вывести информацию о первой командировке из таблицы `trip`. "Первой" считать командировку с самой ранней датой начала..*

```sql
SELECT * FROM trip
ORDER BY date_first
LIMIT 1;
```
```sql
+---------+--------------+--------+----------+------------+------------+
| trip_id | name         | city   | per_diem | date_first | date_last  |
+---------+--------------+--------+----------+------------+------------+
| 1       | Баранов П.Е. | Москва | 700.00   | 2020-01-12 | 2020-01-17 |
+---------+--------------+--------+----------+------------+------------+
```
<hr>

__Важно.__ 
Оператор LIMIT нужно использовать очень осторожно.
Например, если бы в таблице `trip` было несколько командировок с одинаковой датой начала, этот запрос работал бы `НЕВЕРНО`. 
Это связано с тем, что заранее не известно точное значение таких командировок.

[:arrow_up:Оглавление](#Оглавление)


# Запросы, групповые операции

SQL запросы позволяют производить вычисления не только для каждой строки таблицы, но и для группы элементов, расположенных в одном столбце. Для этого используются групповые (агрегатные) функции. 

## Выборка уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово `DISTINCT`, которое размещается сразу после `SELECT`.

<hr>

*ПРИМЕР:*
*Выбрать различных авторов, книги которых хранятся в таблице book.*

```sql
SELECT DISTINCT author
FROM book;
```
```sql
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```
<hr>

Другой способ – использование оператора `GROUP BY`, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после `GROUP BY`.

С помощью `GROUP BY` можно выбрать уникальные элементы столбца, по которому осуществляется группировка.
Результат будет точно такой же как при использовании `DISTINCT`.

```sql
SELECT author
FROM book
GROUP BY author;
```
```sql
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных (групповые функции sum и count)

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

<hr>

```sql
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

1. В таблице `book` определяются строки, в которых в столбце `author` одинаковые значения

Получили 3 различные группы:

- группа I  объединяет две записи, у которых в столбце `author` значение `Булгаков М.А.`;
- группа II объединяет три записи, у которых в столбце `author` значение `Достоевский Ф.М.`;
- группа III объединяет одну запись, у которой в столбце `author` значение `Есенин С.А.`

2. Вместо каждой группы в результирующий запрос включается одна запись.Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это `author`)

3. Дальше можно выполнить вычисления над элементами `КАЖДОЙ` группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция `SUM()`, а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае `amount`):

4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция `COUNT()`, в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает `COUNT()`, если в группе есть пустые значения)

<hr>

*ПРИМЕР:*
*Посчитать, сколько экземпляров книг каждого автора хранится на складе.*

```sql
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```
```sql
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных (групповые функции min, max и avg)

К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

<hr>

*ПРИМЕР:*
*Вывести минимальную цену книги каждого автора*

```sql
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```
```sql
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных с вычислением (групповые функции)

В качестве аргумента групповых функций SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

<hr>

*ПРИМЕР:*
*Вывести суммарную стоимость книг каждого автора.*

```sql
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```
```sql
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вычисление по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. 

Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. 
Для этого после ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются.

<hr>

*ПРИМЕР:*
*Посчитать количество экземпляров книг на складе.*

```sql
SELECT SUM(amount) AS Количество
FROM book;
```
```sql
+------------+
| Количество |
+------------+
| 46         |
+------------+
```
<hr>


[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по условию (групповые функции)

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. 

В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

<hr>

*ПРИМЕР:*
*Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.*

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
```
```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по условию (групповые функции WHERE и HAVING)

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения SQL запроса на выборку на СЕРВЕРЕ:

1. `FROM`
2. `WHERE`
3. `GROUP BY`
4. `HAVING`
5. `SELECT`
6. `ORDER BY`


Сначала определяется таблица, из которой выбираются данные (`FROM`), затем из этой таблицы отбираются записи в соответствии с условием  `WHERE`, выбранные данные агрегируются (`GROUP BY`),  из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после `ORDER BY`.

__Важно!__ 

Порядок `ВЫПОЛНЕНИЯ` запросов - это не порядок `ЗАПИСИ` ключевых слов в запросе на выборку. 

Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее. 

Порядок `ВЫПОЛНЕНИЯ` нужен для того, чтобы понять, почему, например, в `WHERE` нельзя использовать имена выражений из `SELECT`. Просто `SELECT` выполняется компилятором позже, чем `WHERE`, поэтому ему неизвестно, какое там выражение написано.

[:arrow_up:Оглавление](#Оглавление)

# Вложенные запросы

SQL позволяет создавать вложенные запросы. Вложенный запрос (подзапрос, внутренний запрос) – это запрос внутри другого запроса SQL.

Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. 

__Его применяют для:__

- сравнения выражения с результатом вложенного запроса;
- определения того, включено ли выражение в результаты вложенного запроса;
- проверки того, выбирает ли запрос определенные строки.

__Вложенный запрос имеет следующие компоненты:__

- ключевое слово `SELECT` после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент);
- ключевое слово `FROM` и имя таблицы, из которой выбираются данные;
- необязательное предложение `WHERE`;
- необязательное предложение `GROUP BY`:
- необязательное предложение `HAVING`.

Вложенные запросы  могут включаться в `WHERE` или `HAVING` так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):

`WHERE` | `HAVING` выражение оператор_сравнения (вложенный запрос);
`WHERE` | `HAVING` выражение, включающее вложенный запрос;
`WHERE` | `HAVING` выражение [NOT] IN (вложенный запрос);
`WHERE` | `HAVING` выражение  оператор_сравнения  ANY | ALL (вложенный запрос).
Также вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT.

[:arrow_up:Оглавление](#Оглавление)

## Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей `WHERE` как обычное значение совместно с операциями =, <>, >=, <=, >, <.

<hr>

*ПРИМЕР:*
*Вывести информацию о самых дешевых книгах, хранящихся на складе.*

```sql
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
```
```sql
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

<hr>

*ПРИМЕР:*
*Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.*

```sql
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```
```sql
+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN`.

```console
WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
```
Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после `WHERE` получает значение истина. Оператор `NOT IN` выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

<hr>

*ПРИМЕР:*
*Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12*

```sql
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
```
```sql
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)


## Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы `ANY` и `ALL` используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор `ANY`:

`amount > ANY (10, 12)` эквивалентно `amount > 10`

`amount < ANY (10, 12)` эквивалентно `amount < 12`

`amount = ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также `amount IN  (10,12)`

`amount <> ANY (10, 12)` вернет все записи с любым значением `amount`, включая `10` и `12`

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:

`amount > ALL (10, 12)` эквивалентно `amount > 12`

`amount < ALL (10, 12)` эквивалентно `amount < 10`

`amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
`amount <> ALL (10, 12)` вернет все записи кроме тех,  в которых `amount` равно `10` или `12`


__Важно!__ Операторы `ALL` и `ANY` можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

<hr>

*ПРИМЕР:*
*Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.*

```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```
```sql
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. 

В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

<hr>

*ПРИМЕР:*
*Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.*

```sql
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```
```sql
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

# Запросы корректировки данных

SQL позволяет не только выбирать данные из таблиц базы данных, но и корректировать информацию в них. Для этого используются запросы корректировки данных, с помощью которых можно:

- создать пустую таблицу;
- добавить в таблицу записи как совокупность значений;
- добавить записи из другой таблицы;
- добавить записи из другой таблицы, используя вложенный запрос;
- изменить значения в одном столбце;
- изменить значения в нескольких столбцах;
- изменить данные, используя несколько таблиц;
- удалить записи из таблицы;
- создать таблицу на основе данных других таблиц.

## Создание пустой таблицы

Создание таблицы осуществляется с помощью запроса `CREATE`

<hr>

*ПРИМЕР:*
*Создать таблицу поставка (supply), которая имеет ту же структуру, что и таблиц book.*

```sql
CREATE TABLE supply (
    supply_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8,2),
    amount INT
);
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Добавление в таблицу записи как совокупность значений   

Добавление одной записи в таблицу осуществляется с помощью запроса `INSERT`, подробно рассмотренного в первом уроке. Запросы обязательно разделять точкой с запятой.

Допускается вставка нескольких записей одновременно, для этого используется SQL запрос следующего вида:

```sql
INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
VALUES
    (значение_1_1, значение_1_2, ..., значение_1_N),
    (значение_2_1, значение_2_2, ..., значение_2_N),
    ...
    (значение_M_1, значение_M_2, ..., значение_M_N);
```

Например, чтобы добавить в таблицу book две новые записи используется запрос: 

```sql
INSERT INTO book (title, author, price, amount) 
VALUES 
    ('Война и мир','Толстой Л.Н.', 1070.20, 2),
    ('Анна Каренина', 'Толстой Л.Н.', 599.90, 3);
```

<hr>

*ПРИМЕР:*
*Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:*

|supply_id|title|author|price|amount|
|:------- |:--- |:---- |:--- |:---- |
|1|Лирика|Пастернак Б.Л.|518.99|2|
|2|Черный человек|Есенин С.А.|570.20|6|
|3|Белая гвардия|Булгаков М.А.|540.50|7|
|4|Идиот|Достоевский Ф.М.|360.80|3|

```sql
INSERT INTO supply (supply_id, title, author, price, amount)
VALUES 
    (1, 'Лирика', 'Пастернак Б.Л.', 518.99, 2),
    (2, 'Черный человек', 'Есенин С.А.', 570.20, 6),
    (3, 'Белая гвардия', 'Булгаков М.А.', 540.50, 7),
    (4, 'Идиот', 'Достоевский Ф.М.', 360.80, 3);
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Добавление записи из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список `VALUES`), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`.  В нем можно использовать `WHERE`, `GROUP BY`, `ORDER BY`.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

- количество полей в таблице и количество полей в запросе должны совпадать;
- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
- типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа `DECIMAL`, обратная операция – недопустима).


<hr>

*ПРИМЕР:*
*Занести все книги из таблицы supply в таблицу `book`.*

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Добавление записи из другой таблицы, используя вложенный запрос

В запросах на добавление можно использовать вложенные запросы.

<hr>

*ПРИМЕР:*
*Занести из таблицы `supply` в таблицу `book` только те книги, названия которых отсутствуют в таблице `book`.*

```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount FROM supply
WHERE title NOT IN (SELECT title FROM book);

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
```
Вложенным запросом отбираются все названия книг, которые есть в таблице `book`. 
Основным запросом `SELECT` из таблицы `supply` выбираются книги, названия которых нет в результате вложенного запроса. 
Отобранные записи добавляются в конец таблицы bookзапросом на добавление `INSERT`.

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Изменение значения в одном столбце

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. 
При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса `UPDATE`. Простейший запрос на  обновление выглядит так:

```sql
UPDATE таблица SET поле = выражение
```

где 
__таблица__ – имя таблицы, в которой будут проводиться изменения;
__поле__ – поле таблицы, в которое будет внесено изменение;
__выражение__ – выражение,  значение которого будет занесено в поле.

<hr>

*ПРИМЕР:*
*Уменьшить на 30% цену книг в таблице book.*

```sql
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Изменение значения в нескольких столбцах

Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно. 

В этом случае простейший запрос будет выглядеть так:

```sql
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

<hr>

*ПРИМЕР:*
*В столбце `buy` покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбце `buy` количество, а в столбец `buy` занести 0.*

```sql
UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 2      | 0   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 2      | 0   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | -3     | 0   |
+---------+-----------------------+------------------+--------+--------+-----+
```

Как видно из таблицы, без проверки данных, которые занесены в столбец, нельзя запускать запрос на обновление __(может получиться отрицательное значение количества)__.

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Изменение данных, используя несколько таблиц

В запросах на обновление можно использовать несколько таблиц, но тогда

- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, `book.price` – столбец `price` из таблицы `book`, 
`supply.price` – столбец `price` из таблицы `supply`;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`;
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные.

<hr>

*ПРИМЕР:*
*Если в таблице `supply` есть те же книги, что и в таблице `book`, добавлять эти книги в таблицу `book` не имеет смысла. Необходимо увеличить их количество на значение столбца `amount` таблицы `supply`.*

```sql
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Удаление записи из таблицы

Запросы корректировки данных позволяют удалить одну или несколько записей из таблицы.

Простейший запрос на удаление имеет вид:

```sql
DELETE FROM таблица;
```

Этот запрос удаляет все записи из указанной после FROM таблицы.

<hr>

*ПРИМЕР:*
*После того, как информация о книгах из таблицы `supply` перенесена в `book` , необходимо очистить таблицу `supply`.*

```sql
DELETE FROM supply;

SELECT * FROM supply;
```
```sql
/* Результат: */
Affected rows: 4
Affected rows: 0
```

Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.
<hr>

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова `WHERE`:

```sql
DELETE FROM таблица
WHERE условие;
```

[:arrow_up:Оглавление](#Оглавление)

## Создание таблицы на основе данных других таблиц

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

<hr>

*ПРИМЕР:*
*Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше 4. Для всех книг указать одинаковое количество экземпляров 5*

```sql
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```
```sql
/* Результат: */

```
<hr>

[:arrow_up:Оглавление](#Оглавление)


# Запросы SQL к связанным таблица

## Cвязь между таблицами «один ко многим»

Рассмотрим таблицу book(в ней столбец author переименован в name_author):

|book_id|title|name_author|price|amount|
|:---|:---|:---	|:--- |:--- |
|1|Мастер и Маргарита	|Булгаков М.А.|	670.99	|3|
|2|Белая гвардия	|Булгаков М.А.	|540.50|	5|
|3|Идиот	|Достоевский Ф.М.|	460.00|	10|
|4|Братья Карамазовы	|Достоевский Ф.М.	|799.01|	2|
|5|Стихотворения и поэмы	|Есенин С.А.	|650.00|	15|

В этой таблице фамилии авторов повторяются для нескольких книг. 
А что, если придется вместо инициалов для каждого автора хранить его полное имя и отчество? 
Тогда, если в таблице содержится информация о 50 книгах Достоевского, придется 50 раз исправлять «Ф.М.» на «Федор Михайлович». 
При этом, если в некоторых записях использовать «Фёдор Михайлович» (c буквой ё), то мы вообще получим двух разных авторов... 

Чтобы устранить эту проблему в реляционных базах данных создается новая таблица author,  в которой перечисляются все различные авторы, а затем эта таблица связывается с таблицей book. При этом такая связь называется «один ко многим», таблица author называется главной, таблица book – связанной или подчиненной. 

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы. Обозначается это так:



Этапы реализации связи «один ко многим» на следующем примере:

Один автор может написать несколько книг, а одна книга написана только одним автором. Для каждой книги известны ее количество и цена.

1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе
2. Обе таблицы должны содержать первичный ключ, в таблице  bookон уже есть,  в таблицу author добавим ключ author_id
3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id). Для наглядности связь на схеме обозначается стрелкой от ключевого столбца главной таблицы к внешнему ключу связной таблицы



[:arrow_up:Оглавление](#Оглавление)

## Cвязь между таблицами «многие ко многим»

На предыдущем шаге мы реализовали связь «один ко многим» для книг и авторов. Она означает, что каждый автор написал несколько книг, но каждую книгу написал только один автор. На самом деле, это не совсем верное утверждение. Например, книга «12 стульев» написана двумя авторами Ильфом И.А. и Петровым Е.П. С другой стороны, эти авторы написали и другие книги, например «Золотой теленок».

Для соединения таких таблиц используется связь «многие ко многим».

Связь «многие ко многим» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой. Обозначается это так:


Этапы реализации связи «многие ко многим»  на следующем примере:

Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами. Для каждой книги известны ее количество и цена.

1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе:

2. В обеих таблицах необходимо определить первичный ключ, в нашем случае в таблице book он уже есть, поэтому достаточно включить первичный ключ author_id в таблицу author:

3. Создать новую таблицу-связку, состоящую из двух столбцов, соответствующих по имени и типу ключевым столбцам исходных таблиц. Каждый из этих столбцов является внешним ключом (FOREIGN KEY)  и связан с ключевым столбцом каждой таблицы. Для наглядности связи на схеме обозначаются стрелкой от ключевого столбца исходной таблицы к внешнему ключу связной таблицы.

4. Дальше необходимо определиться с первичным ключом таблицы-связки. Можно сделать два ключевых столбца, тогда все записи в этой таблице должны быть уникальными, то есть не повторяться. Для связи автор-книга этот вариант подходит. Но в некоторых случаях записи в таблице-связке могут повторяться, например, если мы будем продавать книги покупателям (один человек может купить несколько книг, а одну и ту же книгу могут купить несколько человек). Тогда в таблицу-связку включают дополнительные столбцы для идентификации записей, например, дату продажи,  также в таблицу-связку добавляют первичный ключ. Мы воспользуемся вторым способом:

[:arrow_up:Оглавление](#Оглавление)

## Cоздание таблицы с внешними ключами

При создании зависимой таблицы (таблицы, которая содержит внешние ключи) необходимо учитывать, что :

каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (в наших примерах это `INT`);
необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:

```sql
FOREIGN KEY (связанное_поле_зависимой_таблицы)  
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
```

По умолчанию любой столбец, кроме ключевого, может содержать значение `NULL`. При создании таблицы это можно переопределить, используя  ограничение `NOT NULL` для этого столбца:

```sql
CREATE TABLE таблица (
    столбец_1 INT NOT NULL, 
    столбец_2 VARCHAR(10) 
);
```
 В созданной таблице в столбец_1 не может содержать пустое значение, а столбец_2 - может.

Для внешних ключей рекомендуется устанавливать ограничение NOT NULL (если это совместимо с другими опциями, которые будут рассмотрены в следующем шаге).

<hr>

*ПРИМЕР:*
*Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре, показанной на логической схеме (таблица genre уже создана, порядок следования столбцов - как на логической схеме в таблице book, genre_id  - внешний ключ) . Для genre_id ограничение о недопустимости пустых значений не задавать.*

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL,
    genre_id INT,
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id),
    FOREIGN KEY (genre_id)  REFERENCES genre(genre_id)
);
```
```sql
Affected rows: 0

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Действия при удалении записи главной таблицы

С помощью выражения `ON DELETE` можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:

- `CASCADE`: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
- `SET NULL`: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение `NULL`. (В этом случае столбец внешнего ключа должен поддерживать установку `NULL`).
- `SET DEFAULT` похоже на `SET NULL` за тем исключением, что значение  внешнего ключа устанавливается не в `NULL`, а в значение по умолчанию для данного столбца.
- `RESTRICT`: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

__Важно!__ Если для столбца установлена опция `SET NULL`, то при его описании нельзя задать ограничение на пустое значение.

<hr>

*ПРИМЕР:*
*Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id.*

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author_id INT NOT NULL,
    genre_id INT, 
    price DECIMAL(8,2),
    amount INT,
    FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,
    FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
);
```
```sql
Affected rows: 0

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

# Запросы на выборку, соединение таблиц

В запросах SQL могут участвовать несколько таблиц базы данных. При этом необходимо указать как эти таблицы соединены между собой. 

Операция соединения JOIN предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

Операторы соединения входят в раздел FROM SQL запросов.

В данном уроке будут созданы запросы:

- для двух таблиц, внутреннее соединение `INNER JOIN`;
- для двух таблиц, внешние соединения `LEFT JOIN` и `RIGHT JOIN`;
- для двух таблиц, перекрестное соединение `CROSS JOIN`;
- выборки данных из нескольких таблиц;
- выборки данных из нескольких таблиц с группировкой;
- выборки данных с применением вложенных запросов;
- вложенные запросы в операторах соединения,
- операторы соединения, использование `USING`.

## Соединение INNER JOIN

Оператор внутреннего соединения `INNER JOIN` соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

```sql
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:

- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
- для полученной «соединённой» строки проверяется условие соединения;
- если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;

<hr>

*ПРИМЕР:*
*Вывести название книг и их авторов.*

```sql
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Поскольку поля `author_id` в таблицах `book` и `author` называются одинаково, необходимо в запросах указывать полную ссылку на них (`book.author_id` и `author.author_id`).

```sql
+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
```
<hr>

В данном запросе осуществляется соединение главной таблицы `author` и зависимой таблицы `book` по ключевому столбцу `author.author_id` и внешнему ключу `book.author_id`. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы book дополняются фамилией и инициалами авторов из таблицы `author`.

[:arrow_up:Оглавление](#Оглавление)

## Внешнее соединение LEFT и RIGHT OUTER JOIN

Оператор внешнего соединения `LEFT OUTER JOIN`  (можно использовать `LEFT JOIN`) соединяет две таблицы. 
Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

```sql
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:

- в результат включается внутреннее соединение (`INNER JOIN`) первой и второй таблицы в соответствии с условием;
- затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями `NULL`.

Соединение `RIGHT JOIN` действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

<hr>

*ПРИМЕР:*
*Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.*

```sql
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;     
```
```sql
+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Перекрестное соединение CROSS JOIN

Оператор перекрёстного соединения, или декартова произведения `CROSS JOIN` (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

```sql
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```

или

```sql
SELECT
 ...
FROM
    таблица_1, таблица_2
...
```
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:

```sql
SELECT name_author, name_genre
FROM 
    author, genre;
```

каждому автору из таблицы `author` поставит в соответствие все возможные жанры из таблицы `genre`:

```sql
+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
```

<hr>

*ПРИМЕР:*
*Есть список городов, хранящийся в таблице city:*


|city_id|name_city|
|:-- |:-- |
|1|Москва|
|2|Санкт-Петербург|
|3|Владивосток|

Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. 
Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. 
Последний столбец назвать `Дата`. 
Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

```sql
SELECT name_city, name_author, (DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND() * 365) DAY)) AS Дата
FROM author, city
ORDER BY name_city, Дата DESC;

```
```sql
Query result:
+-----------------+------------------+------------+
| name_city       | name_author      | Дата       |
+-----------------+------------------+------------+
| Владивосток     | Есенин С.А.      | 2020-10-09 |
| Владивосток     | Достоевский Ф.М. | 2020-08-02 |
| Владивосток     | Булгаков М.А.    | 2020-05-17 |
| Владивосток     | Лермонтов М.Ю.   | 2020-04-10 |
| Владивосток     | Пастернак Б.Л.   | 2020-01-01 |
| Москва          | Есенин С.А.      | 2020-11-27 |
| Москва          | Лермонтов М.Ю.   | 2020-08-24 |
| Москва          | Пастернак Б.Л.   | 2020-06-04 |
| Москва          | Булгаков М.А.    | 2020-01-22 |
| Москва          | Достоевский Ф.М. | 2020-01-03 |
| Санкт-Петербург | Есенин С.А.      | 2020-11-04 |
| Санкт-Петербург | Достоевский Ф.М. | 2020-10-01 |
| Санкт-Петербург | Пастернак Б.Л.   | 2020-04-14 |
| Санкт-Петербург | Булгаков М.А.    | 2020-03-27 |
| Санкт-Петербург | Лермонтов М.Ю.   | 2020-02-04 |
+-----------------+------------------+------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Запросы на выборку из нескольких таблиц

Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение INNER JOIN, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:

```sql

/* first */                           /* second */                          /* third */
+-------------+------------------+    +-------------+------------------+    +-------------+------------------+
| .....       | ........         |    | second      | second_id        | -> | ...         | second_id         |
| first       | first_id         | -> | ....        | first_id         |    | third       | third_id          | 
+-------------+------------------+    +-------------+------------------+    +-------------+------------------+ 
```
тогда запрос на выборку для этих таблиц будет иметь вид:

```sql
SELECT
 ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
```

Если же таблицы связаны так:

```sql

/* first */                           /* third */                          /* second */
+-------------+------------------+    +-------------+------------------+    +-------------+------------------+
| .....       | ........         |    | third       | third_id         |    | ...         | ....             |
| first       | first_id         | -> | ....        | first_id         |    | .....       | ....             |
| .....       | ........         |    | ....        | second_id        | <- | second      | second_id        | 
+-------------+------------------+    +-------------+------------------+    +-------------+------------------+ 
```

то запрос на выборку выглядит следующим образом:

```sql
SELECT
 ...
FROM
    first 
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id 
...
```

В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: `first → third → second`.


<hr>

*ПРИМЕР:*
* Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.*

```sql
SELECT name_genre, title, name_author
FROM
    book b
    INNER JOIN author a ON a.author_id = b.author_id
    INNER JOIN genre g ON g.genre_id = b.genre_id
WHERE g.name_genre LIKE '%роман%'
ORDER BY title;

```
```sql
Query result:
+------------+--------------------+------------------+
| name_genre | title              | name_author      |
+------------+--------------------+------------------+
| Роман      | Белая гвардия      | Булгаков М.А.    |
| Роман      | Братья Карамазовы  | Достоевский Ф.М. |
| Роман      | Игрок              | Достоевский Ф.М. |
| Роман      | Идиот              | Достоевский Ф.М. |
| Роман      | Мастер и Маргарита | Булгаков М.А.    |
+------------+--------------------+------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Запросы для нескольких таблиц с группировкой

В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений.

<hr>

*ПРИМЕР:*
*Посчитать количество экземпляров  книг каждого автора из таблицы author.  Вывести тех авторов, количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.*

```sql
SELECT name_author, SUM(amount) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) < 10 OR SUM(amount) IS NULL
ORDER BY Количество; 
```
```sql
Query result:
+----------------+------------+
| name_author    | Количество |
+----------------+------------+
| Лермонтов М.Ю. | NULL       |
| Пастернак Б.Л. | 2          |
| Булгаков М.А.  | 8          |
+----------------+------------+
```

При использовании соединения `INNER JOIN` мы не можем узнать, что книг Лермонтова на складе нет, но предполагается, что они могут быть.
Чтобы автор Лермонтов был включен в результат, нужно изменить соединение таблиц.


<hr>

[:arrow_up:Оглавление](#Оглавление)

## Запросы для нескольких таблиц со вложенными запросами

В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы.
Вложенный запрос может быть включен:  после ключевого слова `SELECT`,  после `FROM` и в условие отбора после `WHERE (HAVING)`.

<hr>

*ПРИМЕР:*
*Вывести авторов, общее количество книг которых на складе максимально.*
*Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один.*

__Шаг 1.__

Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по `author_id.`

```sql
SELECT author_id, SUM(amount) AS sum_amount
FROM book
GROUP BY author_id
```
```sql
Query result:
+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+
```

__Шаг 2.__

В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23.
Для этого запросу, созданному на `шаге 1`, необходимо присвоить имя (например, `query_in`) и использовать его в качестве таблицы-источника после `FROM`.
Затем уже находить максимум по столбцу `sum_amount`.


```sql
SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
```
```sql
Query result:
+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+
```

__Шаг 3.__ 

Выведем фамилию автора и общее количество книг для него.

```sql
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author 
```

```sql
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+
```

__Шаг 4.__

Включим запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.

```sql
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
```

*ПРИМЕР:*
*Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу book. Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).*


```sql
SELECT DISTINCT name_author FROM author
INNER JOIN book on author.author_id = book.author_id
GROUP BY name_author
HAVING COUNT(DISTINCT genre_id) = 1
```
```sql
Query result:
+------------------+
| name_author      |
+------------------+
| Достоевский Ф.М. |
| Пастернак Б.Л.   |
+------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения `JOIN`. 
При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

```sql
SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
```

Вложенный запрос может стоять как справа, так и слева от оператора JOIN. Допускается использование двух запросов в операторах соединения.

<hr>

*ПРИМЕР:*
*Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.*
*Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена запись в таблице `book`. А также добавлены новые записи.*

Рассмотрим реализацию этого запроса по шагам.

__Шаг 1.__

Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

Запрос:
```sql
SELECT genre_id, SUM(amount) AS sum_amount FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
```
```sql
Query result:
+---------------+------------+
|  genre_id     | sum_amount |
+---------------+------------+
| 1             | 31         |
+---------------+------------+
```

Кажется, что, уже используя этот запрос, можно получить id самого популярного жанра.
Но это не так, поскольку несколько жанров могут иметь одинаковую популярность.
Поэтому нам необходим запрос, который отберет `ВСЕ` жанры, суммарное количество книг которых равно `sum_amount`.

__Шаг 2.__

Используя запрос с предыдущего шага, найдем `id` самых популярных жанров.

Запрос:
```sql
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    ) query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount = query_in_2.sum_amount  
```
```sql
Query result:
+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
```

__Шаг 3.__

Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и id жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре.

Запрос:
```sql
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author, name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
```
```sql
Query result:
+------------------+------------+
| name_author      | name_genre |
+------------------+------------+
| Достоевский Ф.М. | Роман      |
| Булгаков М.А.    | Роман      |
| Пастернак Б.Л.   | Поэзия     |
| Есенин С.А.      | Поэзия     |
+------------------+------------+
```

__Важно!__

1. Обратите внимание, что в группировку включен столбец `genre_id`, который используется в `HAVING`. 
Это связано с тем, что в `HAVING` можно использовать либо столбцы, перечисленные в `GROUP BY`, либо вычисляемые с помощью групповых функций столбцы.
Добавление столбца `genre_id` не влияет на группировку, так как между названием жанра и его `id` - взаимно-однозначное соответствие.
2. Название столбца `genre_id` задается с указанием имени таблицы `(genre.genre_id)`, так как этот столбец входит в структуру двух таблиц `book` и `genre`.
Для этого запроса можно было бы указать и `book.genre_id`, так как эти таблицы связаны внутренним соединением `INNER JOIN` и имеют одинаковые значения в полях `genre.genre_id` и `book.genre_id`.


*ПРИМЕР:*
*Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книги), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде. Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.*


```sql
SELECT title, name_author, name_genre, price, amount
FROM book
    INNER JOIN author ON author.author_id = book.author_id
    INNER JOIN genre ON book.genre_id = genre.genre_id
HAVING name_genre IN (
    SELECT query_in_1.name_genre
    FROM 
        (
            SELECT name_genre, MAX(amount) AS max_amount
            FROM genre INNER JOIN book ON genre.genre_id = book.genre_id
            GROUP BY name_genre
        ) query_in_1
        INNER JOIN
        (
            SELECT name_genre, MAX(amount) AS max_amount
            FROM genre INNER JOIN book ON genre.genre_id = book.genre_id
            GROUP BY name_genre
            HAVING count(amount) > ANY(SELECT MIN(amount) FROM book)
            ORDER BY max_amount DESC
        ) query_in_2
        ON query_in_1.max_amount = query_in_2.max_amount
)
ORDER BY title;
```
```sql
Query result:
+-----------------------+------------------+------------+--------+--------+
| title                 | name_author      | name_genre | price  | amount |
+-----------------------+------------------+------------+--------+--------+
| Белая гвардия         | Булгаков М.А.    | Роман      | 540.50 | 5      |
| Братья Карамазовы     | Достоевский Ф.М. | Роман      | 799.01 | 3      |
| Игрок                 | Достоевский Ф.М. | Роман      | 480.50 | 10     |
| Идиот                 | Достоевский Ф.М. | Роман      | 460.00 | 10     |
| Лирика                | Пастернак Б.Л.   | Поэзия     | 518.99 | 10     |
| Мастер и Маргарита    | Булгаков М.А.    | Роман      | 670.99 | 3      |
| Стихотворения и поэмы | Есенин С.А.      | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.      | Поэзия     | 570.20 | 6      |
+-----------------------+------------------+------------+--------+--------+
```

<hr>


[:arrow_up:Оглавление](#Оглавление)

## Операция соединение, использование USING()

При описании соединения таблиц с помощью `JOIN` в некоторых случаях вместо `ON` и следующего за ним условия можно использовать оператор `USING()`.

`USING` позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах.
Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, `genre.genre_id = book.genre_id`), тогда можно использовать предложение `USING` для реализации операции `JOIN`. 

При этом после `SELECT`, при использовании столбцов из `USING()`, необязательно указывать, из какой именно таблицы берется столбец.

<hr>

*ПРИМЕР:*
*Вывести название книг, фамилии и id их авторов.*

Вариант с `ON`

```sql
SELECT title, name_author, author.author_id /* явно указать таблицу - обязательно */
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Вариант с `USING`

```sql
SELECT title, name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно*/
FROM 
    author INNER JOIN book
    USING(author_id);
```

Результат (одинаковый для обоих запросов):

```sql
+-----------------------+------------------+-----------+
| title                 | name_author      | author_id |
+-----------------------+------------------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 1         |
| Белая гвардия         | Булгаков М.А.    | 1         |
| Идиот                 | Достоевский Ф.М. | 2         |
| Братья Карамазовы     | Достоевский Ф.М. | 2         |
| Игрок                 | Достоевский Ф.М. | 2         |
| Стихотворения и поэмы | Есенин С.А.      | 3         |
| Черный человек        | Есенин С.А.      | 3         |
| Лирика                | Пастернак Б.Л.   | 4         |
+-----------------------+------------------+-----------+
```

Запись условия соединения с `ON` является более общим случаем, так как

- позволяет задавать соединение не только по одноименным полям;
- позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение, например, можно указать связь двух таблиц по двум и более столбцам.

*ПРИМЕР:*
*В таблице `supply` занесена информация о книгах, поступивших на склад.*

|supply_id|title|author|price|amount|
|:-- |:-- |:-- |:-- |:-- |
|1|Доктор Живаго|Пастернак Б.Л.|618.99|3|
|2|Черный человек|Есенин С.А.|570.20|6|
|3|Евгений Онегин|Пушкин А.С.|440.80|5|
|4|Идиот|Достоевский Ф.М.|360.80|3|

Если в таблицах `supply`  и `book` есть одинаковые книги,  вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковым названием.

__Важно.__ 

В данном примере для соединения `book` и `supply` использовать `USING` нельзя, так как: 

- в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author, столбец name_author),  а в таблице supply фамилии занесены в столбец author;
- для однозначной идентификации книги нужно указать, что совпадают не только названия, но и авторы книг.

_Запрос:_
```sql
SELECT book.title, name_author
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author;
```

_Результат:_
```sql
+----------------+------------------+
| title          | name_author      |
+----------------+------------------+
| Идиот          | Достоевский Ф.М. |
| Черный человек | Есенин С.А.      |
+----------------+------------------+
```

*ПРИМЕР:*
*Если в таблицах `supply` и `book` есть одинаковые книги, которые имеют равную цену, вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах `supply` и `book`, столбцы назвать `Название`, `Автор` и `Количество`.*

_Запрос:_
```sql
SELECT book.title AS Название, name_author AS Автор, (book.amount + supply.amount) AS Количество
FROM author
    INNER JOIN book USING (author_id)
    INNER JOIN supply ON book.title = supply.title
                         AND book.price = supply.price
                         AND author.name_author = supply.author
```

_Результат:_
```sql
Query result:
+----------------+-------------+------------+
| Название       | Автор       | Количество |
+----------------+-------------+------------+
| Черный человек | Есенин С.А. | 12         |
+----------------+-------------+------------+
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

# Запросы корректировки, соединение таблиц

С помощью запросов корректировки данных решим задачу о занесении в базу книг, привезенных на склад поставщиком.

База данных о книгах  включает три таблицы `genre`, `author` и `book`, информация о поставке занесена в таблицу `supply`. С разными типами книг из поставки необходимо выполнить разные действия:

- для книг, которые уже есть на складе по той же цене, что и в поставке, - увеличить их количество на значение, указанное в поставке (пример);
- для книг, которые уже есть на складе, но цена книги в поставке отличается, - увеличить количество экземпляров и вычислить новую цену, при расчете учесть количество имеющихся и новых экземпляров книг (задание);
- для книг, которых на складе нет, - проверить, есть ли  автор книги в базе, если нет - занести фамилию автора, а потом добавить новую запись о книге, оставив поле для описания жанра пустым;
- задать жанр для новых книг.

Еще одно типовое действие на складе - удаление устаревшей информации. С помощью запросов корректировки удаление данных о жанрах, авторах и книгах выполняется в зависимости от того, какие свойства внешних ключей были указаны в таблицах при их создании:

- каскадное удаление записей связанных таблиц;
- удаление записей в главной таблице с сохранением записей в зависимой;
- удаление записей с использованием информации из связанных таблиц.

## Запросы на обновление, связанные таблицы

В запросах на обновление можно использовать связанные таблицы:

```sql
UPDATE таблица_1
     ... JOIN таблица_2
     ON выражение
     ...
SET ...   
WHERE ...;
```

При этом исправлять данные можно во всех используемых в запросе таблицах.

**Пример**

Для книг, которые уже есть на складе (в таблице book) по той же цене, что и в поставке (`supply`), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.

Этот запрос должен отобрать строки из таблиц `book` и `supply` такие, что у них совпадают и автор, и название книги. Но в таблице `supply` фамилия автора записана не числом (`id`), а текстом. Следовательно, чтобы выполнить сравнение по фамилии автора нужно "подтянуть" таблицу `author`,  которая связана с bookпо столбцу `author_id`.  И в логическом выражении, описывающем соединение таблиц, можно будет использовать столбцы из таблиц `book`, `author` и `supply`. 

Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор `AND`. 

условие соединения можно записать в виде:

```sql
book INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                          and supply.author = author.name_author
```

*Запрос:*

```sql
UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    supply.amount = 0   
WHERE book.price = supply.price;

SELECT * FROM book;

SELECT * FROM supply;
```

*Результат:*

```sql
Affected rows: 4

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 8

Query result:
+-----------+-----------------------+------------------+--------+--------+
| supply_id | title                 | author           | price  | amount |
+-----------+-----------------------+------------------+--------+--------+
| 1         | Доктор Живаго         | Пастернак Б.Л.   | 380.80 | 4      |
| 2         | Черный человек        | Есенин С.А.      | 570.20 | 0      |
| 3         | Белая гвардия         | Булгаков М.А.    | 540.50 | 0      |
| 4         | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
| 5         | Стихотворения и поэмы | Лермонтов М.Ю.   | 255.90 | 4      |
| 6         | Остров сокровищ       | Стивенсон Р.Л.   | 599.99 | 5      |
+-----------+-----------------------+------------------+--------+--------+
Affected rows: 6
```
Под нужное нам условие подходят две книги __«Белая гвардия» Булгакова__ и __«Черный человек» Есенина__.
В таблице `book` их количество увеличилось, а в таблице `supply` - обнулилось.

<hr>

**Задание**

*Для книг, которые уже есть на складе (в таблице `book`), но по другой цене, чем в поставке (`supply`),  необходимо в таблице `book` увеличить количество на значение, указанное в поставке,  и пересчитать цену. А в таблице `supply` обнулить количество этих книг. Формула для пересчета цены:*

```python
price = (p1 * k1 + p2 * k2) / (k1 + k2)
# где p1, p2 - цена книги в таблицах book и supply;
# где k1, k2 - количество книг в таблицах book и supply;
```

*Запрос:*

```sql
UPDATE book
    INNER JOIN supply USING(title)
    INNER JOIN author ON author.author_id = book.author_id
                     AND author.name_author = supply.author
SET book.amount = book.amount + supply.amount,
    book.price = (book.price * book.amount + supply.price * supply.amount) / (book.amount + supply.amount),
    supply.amount = 0
WHERE book.price <> supply.price;

SELECT * FROM book;

SELECT * FROM supply;
```

*Результат:*

```sql
Affected rows: 2

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 5      |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 8

Query result:
+-----------+-----------------------+------------------+--------+--------+
| supply_id | title                 | author           | price  | amount |
+-----------+-----------------------+------------------+--------+--------+
| 1         | Доктор Живаго         | Пастернак Б.Л.   | 380.80 | 4      |
| 2         | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 3         | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 4         | Идиот                 | Достоевский Ф.М. | 360.80 | 0      |
| 5         | Стихотворения и поэмы | Лермонтов М.Ю.   | 255.90 | 4      |
| 6         | Остров сокровищ       | Стивенсон Р.Л.   | 599.99 | 5      |
+-----------+-----------------------+------------------+--------+--------+
Affected rows: 6
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Запросы на добавление, связанные таблицы

Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:

```sql
INSERT INTO таблица (список_полей)
SELECT список_полей_из_других_таблиц
FROM 
    таблица_1 
    ... JOIN таблица_2 ON ...
    ...
```

**Пример**

*В таблице `supply` есть новые книги, которых на складе еще не было. 
Прежде чем добавлять их в таблицу `book`, необходимо из таблицы `supply` отобрать новых авторов, если таковые имеются.*

*Запрос:*

```sql
SELECT name_author, supply.author
FROM 
    author 
    RIGHT JOIN supply ON author.name_author = supply.author;
```

Поскольку таблица `author` и поле в таблице `supply` называются одинаково, желательно указывать полную ссылку на поле (`supply.author`), чтобы запрос был более читабельным.

*Результат:*

```sql
+------------------+------------------+
| name_author      | author           |
+------------------+------------------+
| Булгаков М.А.    | Булгаков М.А.    |
| Достоевский Ф.М. | Достоевский Ф.М. |
| Есенин С.А.      | Есенин С.А.      |
| Пастернак Б.Л.   | Пастернак Б.Л.   |
| Лермонтов М.Ю.   | Лермонтов М.Ю.   |
| None             | Стивенсон Р.Л.   |
+------------------+------------------+
```
Выполнив правое внутреннее соединение таблиц, получили значение `Null` (`None`) в поле `name_author` в строке того автора, которого нет в таблице `author`, в нашем случае это Стивенсон.

Теперь достаточно в запросе задать условие отбора, и список новых авторов готов для включения в таблицу `author`.

*Запрос:*

```sql
SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;
```

*Результат:*

```sql
+----------------+
| author         |
+----------------+
| Стивенсон Р.Л. |
+----------------+
```

<hr>

**Задание**

*Включить новых авторов в таблицу author с помощью запроса на добавление, а затем вывести все данные из таблицы author.  Новыми считаются авторы, которые есть в таблице supply, но нет в таблице author.*


*Запрос:*

```sql
INSERT INTO author(name_author)
SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;

SELECT * FROM author;
```

*Результат:*

```sql
Affected rows: 1

Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 4         | Пастернак Б.Л.   |
| 5         | Лермонтов М.Ю.   |
| 6         | Стивенсон Р.Л.   |
+-----------+------------------+
Affected rows: 6
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Запрос на добавление, связанные таблицы

Следующий шаг - добавить новые записи о книгах, которые есть в таблице `supply` и нет в таблице `book`.
(В таблицах `supply` и `book` сохранены изменения предыдущих шагов).
Поскольку в таблице `supply` не указан жанр книги, оставить его пока пустым (занести значение `Null`).

**Пример**

Прежде всего необходимо сформировать запрос с полями, которые соответствуют полям таблицы `book`, так как использовать только таблицу `supply` нельзя - в ней вместо кода автора стоит его фамилия. 

*Запрос:*

```sql
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author;
```

*Результат:*

```sql
+-----------------------+-----------+--------+--------+
| title                 | author_id | price  | amount |
+-----------------------+-----------+--------+--------+
| Доктор Живаго         | 4         | 380.80 | 4      |
| Черный человек        | 3         | 570.20 | 0      |
| Белая гвардия         | 1         | 540.50 | 0      |
| Идиот                 | 2         | 360.80 | 0      |
| Стихотворения и поэмы | 5         | 255.90 | 4      |
| Остров сокровищ       | 6         | 599.99 | 5      |
+-----------------------+-----------+--------+--------+
```

Далее необходимо отобрать только новые книги из таблицы `supply`.
Как видно из таблицы с результатами запроса, в тех записях, которые нужно добавить, значения столбца `amount` не равны 0
(количество уже учтенных книг обнулены предыдущим запросом).

Добавим это условие в запрос.

*Запрос:*

```sql
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;
```

*Результат:*

```sql
+-----------------------+-----------+--------+--------+
| title                 | author_id | price  | amount |
+-----------------------+-----------+--------+--------+
| Доктор Живаго         | 4         | 380.80 | 4      |
| Стихотворения и поэмы | 5         | 255.90 | 4      |
| Остров сокровищ       | 6         | 599.99 | 5      |
+-----------------------+-----------+--------+--------+
```

<hr>

**Задание**

*Добавить новые книги из таблицы `supply` в таблицу `book` на основе сформированного выше запроса. Затем вывести для просмотра таблицу `book`.*


*Запрос:*

```sql

```

*Результат:*

```sql

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Запрос на обновление, вложенные запросы


<hr>

**Задание**

*Условие*


*Запрос:*

```sql

```

*Результат:*

```sql

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Каскадное удаление записей связанных таблиц


<hr>

**Задание**

*Условие*


*Запрос:*

```sql

```

*Результат:*

```sql

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Удаление записей главной таблицы с сохранением записей в зависимой


<hr>

**Задание**

*Условие*


*Запрос:*

```sql

```

*Результат:*

```sql

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Удаление записей, использование связанных таблиц


<hr>

**Задание**

*Условие*


*Запрос:*

```sql

```

*Результат:*

```sql

```
<hr>

[:arrow_up:Оглавление](#Оглавление)

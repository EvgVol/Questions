# SQL (Structured Query Language)

## Оглавление

0. [Основные принципы реляционных баз данных](#основные-принципы-реляционных-баз-данных)
1. [Терминология реляционных баз данных](#терминология-реляционных-баз-данных)
2. [Отношение, реляционная модель](#основные-принципы-реляционных-баз-данных)
3. [Выбор типов данных для полей](#выбор-типов-данных-для-полей)
4. [Выборка данных](#выборка-данных)
    1. [Выборка данных, вычисляемые столбцы, математические функции](#выборка-данных-вычисляемые-столбцы-математические-функции)
    2. [Выборка данных, вычисляемые столбцы, логические функции](#выборка-данных-вычисляемые-столбцы-логические-функции)
    3. [Выборка данных по условию](#выборка-данных-по-условию)
    4. [Выборка данных, логические операции](#выборка-данных-логические-операции)
    5. [Выборка данных, операторы BETWEEN, IN](#выборка-данных-операторы-between-in)
    6. [Выборка данных с сортировкой](#выборка-данных-с-сортировкой)
    7. [Выборка данных, оператор LIKE](#выборка-данных-оператор-like)
    8. [Выборка данных, оператор LIMIT]()
5. [Запросы, групповые операции](#запросы-групповые-операции)
    1. [Выборка уникальных элементов столбца]()
    2. [Выборка данных (групповые функции sum и count)]()
    3. [Выборка данных (групповые функции min, max и avg)]()
    4. [Выборка данных с вычислением (групповые функции)]()
    5. [Вычисление по таблице целиком]()
    6. [Выборка данных по условию (групповые функции)]()
    7. [Выборка данных по условию (групповые функции WHERE и HAVING)]()
6. [Вложенные запросы](#вложенные-запросы)
    1. [Вложенный запрос, возвращающий одно значение](#вложенный-запрос-возвращающий-одно-значение)
    2. [Использование вложенного запроса в выражении](#использование-вложенного-запроса-в-выражении)
    3. [Вложенный запрос, оператор IN](#вложенный-запрос-оператор-in)
    4. [Вложенный запрос, операторы ANY и ALL](#вложенный-запрос-операторы-any-и-all)
    5. [Вложенный запрос после SELECT](#вложенный-запрос-после-select)
6. [Запросы корректировки данных](#запросы-корректировки-данных)
    1. [Создание пустой таблицы](#создание-пустой-таблицы)
    2. [Добавление в таблицу записи как совокупность значений](#добавление-в-таблицу-записи-как-совокупность-значений)
    3. [Добавление записи из другой таблицы](#добавление-записи-из-другой-таблицы)
    4. [Добавление записи из другой таблицы, используя вложенный запрос](#добавление-записи-из-другой-таблицы-используя-вложенный-запрос)
    5. [Изменение значения в одном столбце](#изменение-значения-в-одном-столбце)
    6. [Изменение значения в нескольких столбцах](#изменение-значения-в-нескольких-столбцах)
    7. [Изменение данных, используя несколько таблиц](#изменение-данных-используя-несколько-таблиц)
    8. [Удаление записи из таблицы](#удаление-записи-из-таблицы)
    9. [Создание таблицы на основе данных других таблиц](#создание-таблицы-на-основе-данных-других-таблиц)
7. [Прочие примеры](examples/README.md)


* SQL - это декларативный язык программирования (язык запросов), который используют для создания, обработки и хранения данных в реляционных базах данных.

Реляционная модель была разработана в конце 1960-х годов Е.Ф.Коддом.
Она определяет способ представления данных (структуру данных), методы защиты данных (целостность данных), и операции, которые можно выполнять с данными (манипулирование данными).

Эта модель лежит в основе всех реляционных баз данных до настоящего времени.

## Основные принципы реляционных баз данных:

- все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
- в пересечение строки и столбца таблицы можно занести только одно значение;
- все операции выполняются над целыми отношениями и результатом этих операций является отношение.


## Терминология реляционных баз данных:

* отношение  – это структура данных целиком, набор записей (в обычном понимании – таблица);

* кортеж – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <001, Борин С.А, 234-01-23, программист>, все кортежи в отношении должны быть различны;

* мощность – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;

* атрибут – это столбец в таблице (более распространенный термин – поле);

* размерность – это число атрибутов в таблице;
размерность отношения должна быть больше 0, порядок следования атрибутов существенен;

* домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута Должность домен – {инженер, программист}.

[:arrow_up:Оглавление](#Оглавление)

## Отношение, реляционная модель

База данных, в том числе и реляционная, используется для формального описания некоторой предметной области реального мира, например, склада, учебного процесса и пр. Обязательным этапом перед созданием базы данных является ее проектирование.

Перед созданием таблицы в базе данных необходимо описать ее структуру. Для этого выполняется следующая последовательность шагов:

1. Дать таблице имя, пусть она будет называться `book`, вот некоторые правила для выбора имен таблиц:

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
- имя должно быть уникальным в пределах базы данных.

Также рекомендуется:

- чтобы имя было существительным в единственном числе;
- имя должно быть понятным и соответствовать тому объекту, который оно описывает;
- имя должно быть как можно короче, максимум до 10 символов.

2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять.

Правила по выбору имени поля информационного объекта:

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
- имя поля должно быть уникальным в пределах таблицы.

Рекомендации по выбору имени поля информационного объекта:

- имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;
- имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.

3. Включить ключевое поле `book_id`, которое является `ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ` каждой реляционной таблицы. 
Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.

Рекомендации по именованию  ключевых полей:

- имя должно состоять из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать `id`.

[:arrow_up:Оглавление](#Оглавление)

## Выбор типов данных для полей 

После описания структуры таблицы необходимо выбрать типы данных для каждого поля.

### Основные типы данных SQL:

| Тип данных        | Описание                                       | Пример                            |
| :-----------------| :--------------------------------------------  | :-------------------------------- |
| INT (INTEGER)     | Целое число от -2 147 483 648 до 2 147 483 647 | -5671205                          |
| DECIMAL (NUMERIC) | Вещественное число                             | -3.294                            |
| DATE              | Дата                                           |                                   |
| VARCHAR           |                                                |                                   |

[:arrow_up:Оглавление](#Оглавление)


# Выборка данных

... (пропущено)

## Выборка данных, вычисляемые столбцы, математические функции

| Функция           | Описание                                                | Пример                              |
| :-----------------| :--------------------------------------------           | :--------------------------------   |
| CEILING(x)        | возвращает наименьшее целое число, большее или равное x | CEILING(4.2)=5 CEILING(-5.8)=-5     |
| ROUND(x, k)       | округляет значение x до k знаков после запятой          | ROUND(4.361)=4 ROUND(5.86592,1)=5.9 |
| FLOOR(x)          | возвращает наибольшее целое число, меньшее или равное x | FLOOR(4.2)=4 FLOOR(-5.8)=-6         |
| POWER(x, y)       | возведение x в степень y                                | POWER(3,4)=81.0                     |
| SQRT(x)           | квадратный корень из x                                  | SQRT(4)=2.0 SQRT(2)=1.41...         |
| DEGREES(x)        | конвертирует значение x из радиан в градусы             | DEGREES(3) = 171.8...               |
| RADIANS(x)        | конвертирует значение x из градусов в радианы           | RADIANS(180)=3.14...                |
| ABS(x)            | модуль числа x                                          | ABS(-1) = 1  ABS(1) = 1             |
| PI()              | pi = 3.1415926...                                       |                                     |

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF()`:

```bash
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1, в противном случае –  значение выражения_2.
Все три параметра `IF()` являются `обязательными`.

Допускается использование вложенных функций, вместо выражения_1 или выражения_2 может стоять новая функция `IF`.

<hr>

*ПРИМЕР:*
*При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать new_price. Значение округлить до двух знаков после запятой.*

```sql
SELECT author, title,
    ROUND(IF(author = 'Булгаков М.А.', price * 1.10, IF(author = 'Есенин С.А.', price * 1.05, price)), 2) AS new_price 
FROM book;
```
```sql
Query result:
+------------------+-----------------------+-----------+
| author           | title                 | new_price |
+------------------+-----------------------+-----------+
| Булгаков М.А.    | Мастер и Маргарита    | 738.09    |
| Булгаков М.А.    | Белая гвардия         | 594.55    |
| Достоевский Ф.М. | Идиот                 | 460.00    |
| Достоевский Ф.М. | Братья Карамазовы     | 799.01    |
| Есенин С.А.      | Стихотворения и поэмы | 682.50    |
+------------------+-----------------------+-----------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию.

Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. 

Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

<hr>

*ПРИМЕР:*
*Вывести название и цену тех книг, цены которых меньше 600 рублей.*

```sql
SELECT title, price FROM book WHERE price < 600;
```
```sql
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, логические операции

Логическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

- круглые скобки
- умножение  (*),  деление (/)
- сложение  (+), вычитание (-)
- операторы сравнения (=, >, <, >=, <=, <>)
- NOT
- AND
- OR

<hr>

*ПРИМЕР:*
*Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей*

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```
```sql
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, операторы BETWEEN, IN

Логическое выражение после ключевого слова `WHERE` может включать операторы  `BETWEEN` и `IN`. 
Приоритет у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `NOT`, `AND`, `OR`.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

<hr>

*ПРИМЕР:*
*Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.*

```sql
SELECT title, amount
FROM book
WHERE amount BETWEEN 5 AND 14;
```
```sql
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)


## Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. 
Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. 

При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. 
По умолчанию `ORDER BY` выполняет сортировку по возрастанию. 

Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

- названием столбца;
- номером столбца;
- именем столбца (указанным после AS).

<hr>

*ПРИМЕР:*
*Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.*

```sql
SELECT title, author, price
FROM book
ORDER BY title;
```
```sql
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
```

Аналогичный результат получится при использовании запроса:

```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, оператор LIKE

Оператор `LIKE` используется для сравнения строк. 

В отличие от операторов отношения равно (=) и не равно (<>), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. 

Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. 

Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

| Символ шаблона | Описание                                         | Пример                                      |
| :--------------| :--------------------------------------------    | :--------------------------------           |
| %              | Любая строка, содержащая ноль или более символов | SELECT * FROM book WHERE author LIKE '%М.'  |
| -              | Любой одиночный символ                           | SELECT * FROM book WHERE title LIKE 'Поэм_' |

<hr>

*ПРИМЕР:*
*Вывести названия книг, начинающихся с буквы «Б».*

```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```
```sql
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных, оператор LIMIT

Для ограничения вывода записей в SQL используется оператор `LIMIT` , после которого указывается количество строк.
Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`. `LIMIT` размещается после раздела `ORDER BY`.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 

<hr>

*ПРИМЕР:*
*Вывести информацию о первой командировке из таблицы `trip`. "Первой" считать командировку с самой ранней датой начала..*

```sql
SELECT * FROM trip
ORDER BY date_first
LIMIT 1;
```
```sql
+---------+--------------+--------+----------+------------+------------+
| trip_id | name         | city   | per_diem | date_first | date_last  |
+---------+--------------+--------+----------+------------+------------+
| 1       | Баранов П.Е. | Москва | 700.00   | 2020-01-12 | 2020-01-17 |
+---------+--------------+--------+----------+------------+------------+
```
<hr>

__Важно.__ 
Оператор LIMIT нужно использовать очень осторожно.
Например, если бы в таблице `trip` было несколько командировок с одинаковой датой начала, этот запрос работал бы `НЕВЕРНО`. 
Это связано с тем, что заранее не известно точное значение таких командировок.

[:arrow_up:Оглавление](#Оглавление)


# Запросы, групповые операции

SQL запросы позволяют производить вычисления не только для каждой строки таблицы, но и для группы элементов, расположенных в одном столбце. Для этого используются групповые (агрегатные) функции. 

## Выборка уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово `DISTINCT`, которое размещается сразу после `SELECT`.

<hr>

*ПРИМЕР:*
*Выбрать различных авторов, книги которых хранятся в таблице book.*

```sql
SELECT DISTINCT author
FROM book;
```
```sql
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```
<hr>

Другой способ – использование оператора `GROUP BY`, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после `GROUP BY`.

С помощью `GROUP BY` можно выбрать уникальные элементы столбца, по которому осуществляется группировка.
Результат будет точно такой же как при использовании `DISTINCT`.

```sql
SELECT author
FROM book
GROUP BY author;
```
```sql
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных (групповые функции sum и count)

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

<hr>

```sql
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

1. В таблице `book` определяются строки, в которых в столбце `author` одинаковые значения

Получили 3 различные группы:

- группа I  объединяет две записи, у которых в столбце `author` значение `Булгаков М.А.`;
- группа II объединяет три записи, у которых в столбце `author` значение `Достоевский Ф.М.`;
- группа III объединяет одну запись, у которой в столбце `author` значение `Есенин С.А.`

2. Вместо каждой группы в результирующий запрос включается одна запись.Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это `author`)

3. Дальше можно выполнить вычисления над элементами `КАЖДОЙ` группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция `SUM()`, а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае `amount`):

4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция `COUNT()`, в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает `COUNT()`, если в группе есть пустые значения)

<hr>

*ПРИМЕР:*
*Посчитать, сколько экземпляров книг каждого автора хранится на складе.*

```sql
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```
```sql
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных (групповые функции min, max и avg)

К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

<hr>

*ПРИМЕР:*
*Вывести минимальную цену книги каждого автора*

```sql
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```
```sql
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных с вычислением (групповые функции)

В качестве аргумента групповых функций SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

<hr>

*ПРИМЕР:*
*Вывести суммарную стоимость книг каждого автора.*

```sql
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```
```sql
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вычисление по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. 

Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. 
Для этого после ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются.

<hr>

*ПРИМЕР:*
*Посчитать количество экземпляров книг на складе.*

```sql
SELECT SUM(amount) AS Количество
FROM book;
```
```sql
+------------+
| Количество |
+------------+
| 46         |
+------------+
```
<hr>


[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по условию (групповые функции)

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. 

В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

<hr>

*ПРИМЕР:*
*Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.*

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
```
```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по условию (групповые функции WHERE и HAVING)

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения SQL запроса на выборку на СЕРВЕРЕ:

1. `FROM`
2. `WHERE`
3. `GROUP BY`
4. `HAVING`
5. `SELECT`
6. `ORDER BY`


Сначала определяется таблица, из которой выбираются данные (`FROM`), затем из этой таблицы отбираются записи в соответствии с условием  `WHERE`, выбранные данные агрегируются (`GROUP BY`),  из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после `ORDER BY`.

__Важно!__ 

Порядок `ВЫПОЛНЕНИЯ` запросов - это не порядок `ЗАПИСИ` ключевых слов в запросе на выборку. 

Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее. 

Порядок `ВЫПОЛНЕНИЯ` нужен для того, чтобы понять, почему, например, в `WHERE` нельзя использовать имена выражений из `SELECT`. Просто `SELECT` выполняется компилятором позже, чем `WHERE`, поэтому ему неизвестно, какое там выражение написано.

[:arrow_up:Оглавление](#Оглавление)

# Вложенные запросы

SQL позволяет создавать вложенные запросы. Вложенный запрос (подзапрос, внутренний запрос) – это запрос внутри другого запроса SQL.

Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. 

__Его применяют для:__

- сравнения выражения с результатом вложенного запроса;
- определения того, включено ли выражение в результаты вложенного запроса;
- проверки того, выбирает ли запрос определенные строки.

__Вложенный запрос имеет следующие компоненты:__

- ключевое слово `SELECT` после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент);
- ключевое слово `FROM` и имя таблицы, из которой выбираются данные;
- необязательное предложение `WHERE`;
- необязательное предложение `GROUP BY`:
- необязательное предложение `HAVING`.

Вложенные запросы  могут включаться в `WHERE` или `HAVING` так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):

`WHERE` | `HAVING` выражение оператор_сравнения (вложенный запрос);
`WHERE` | `HAVING` выражение, включающее вложенный запрос;
`WHERE` | `HAVING` выражение [NOT] IN (вложенный запрос);
`WHERE` | `HAVING` выражение  оператор_сравнения  ANY | ALL (вложенный запрос).
Также вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT.

[:arrow_up:Оглавление](#Оглавление)

## Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей `WHERE` как обычное значение совместно с операциями =, <>, >=, <=, >, <.

<hr>

*ПРИМЕР:*
*Вывести информацию о самых дешевых книгах, хранящихся на складе.*

```sql
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
```
```sql
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

<hr>

*ПРИМЕР:*
*Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.*

```sql
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```
```sql
+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN`.

```console
WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
```
Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после `WHERE` получает значение истина. Оператор `NOT IN` выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

<hr>

*ПРИМЕР:*
*Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12*

```sql
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
```
```sql
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)


## Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы `ANY` и `ALL` используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор `ANY`:

`amount > ANY (10, 12)` эквивалентно `amount > 10`

`amount < ANY (10, 12)` эквивалентно `amount < 12`

`amount = ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также `amount IN  (10,12)`

`amount <> ANY (10, 12)` вернет все записи с любым значением `amount`, включая `10` и `12`

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:

`amount > ALL (10, 12)` эквивалентно `amount > 12`

`amount < ALL (10, 12)` эквивалентно `amount < 10`

`amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
`amount <> ALL (10, 12)` вернет все записи кроме тех,  в которых `amount` равно `10` или `12`


__Важно!__ Операторы `ALL` и `ANY` можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

<hr>

*ПРИМЕР:*
*Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.*

```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```
```sql
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. 

В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

<hr>

*ПРИМЕР:*
*Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.*

```sql
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```
```sql
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

# Запросы корректировки данных

SQL позволяет не только выбирать данные из таблиц базы данных, но и корректировать информацию в них. Для этого используются запросы корректировки данных, с помощью которых можно:

- создать пустую таблицу;
- добавить в таблицу записи как совокупность значений;
- добавить записи из другой таблицы;
- добавить записи из другой таблицы, используя вложенный запрос;
- изменить значения в одном столбце;
- изменить значения в нескольких столбцах;
- изменить данные, используя несколько таблиц;
- удалить записи из таблицы;
- создать таблицу на основе данных других таблиц.

## Создание пустой таблицы

Создание таблицы осуществляется с помощью запроса `CREATE`

<hr>

*ПРИМЕР:*
*Создать таблицу поставка (supply), которая имеет ту же структуру, что и таблиц book.*

```sql
CREATE TABLE supply (
    supply_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8,2),
    amount INT
);
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Добавление в таблицу записи как совокупность значений   

Добавление одной записи в таблицу осуществляется с помощью запроса `INSERT`, подробно рассмотренного в первом уроке. Запросы обязательно разделять точкой с запятой.

Допускается вставка нескольких записей одновременно, для этого используется SQL запрос следующего вида:

```sql
INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
VALUES
    (значение_1_1, значение_1_2, ..., значение_1_N),
    (значение_2_1, значение_2_2, ..., значение_2_N),
    ...
    (значение_M_1, значение_M_2, ..., значение_M_N);
```

Например, чтобы добавить в таблицу book две новые записи используется запрос: 

```sql
INSERT INTO book (title, author, price, amount) 
VALUES 
    ('Война и мир','Толстой Л.Н.', 1070.20, 2),
    ('Анна Каренина', 'Толстой Л.Н.', 599.90, 3);
```

<hr>

*ПРИМЕР:*
*Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:*

|supply_id|title|author|price|amount|
|:------- |:--- |:---- |:--- |:---- |
|1|Лирика|Пастернак Б.Л.|518.99|2|
|2|Черный человек|Есенин С.А.|570.20|6|
|3|Белая гвардия|Булгаков М.А.|540.50|7|
|4|Идиот|Достоевский Ф.М.|360.80|3|

```sql
INSERT INTO supply (supply_id, title, author, price, amount)
VALUES 
    (1, 'Лирика', 'Пастернак Б.Л.', 518.99, 2),
    (2, 'Черный человек', 'Есенин С.А.', 570.20, 6),
    (3, 'Белая гвардия', 'Булгаков М.А.', 540.50, 7),
    (4, 'Идиот', 'Достоевский Ф.М.', 360.80, 3);
```

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Добавление записи из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список `VALUES`), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`.  В нем можно использовать `WHERE`, `GROUP BY`, `ORDER BY`.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

- количество полей в таблице и количество полей в запросе должны совпадать;
- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
- типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа `DECIMAL`, обратная операция – недопустима).


<hr>

*ПРИМЕР:*
*Занести все книги из таблицы supply в таблицу `book`.*

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Добавление записи из другой таблицы, используя вложенный запрос

В запросах на добавление можно использовать вложенные запросы.

<hr>

*ПРИМЕР:*
*Занести из таблицы `supply` в таблицу `book` только те книги, названия которых отсутствуют в таблице `book`.*

```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount FROM supply
WHERE title NOT IN (SELECT title FROM book);

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
```
Вложенным запросом отбираются все названия книг, которые есть в таблице `book`. 
Основным запросом `SELECT` из таблицы `supply` выбираются книги, названия которых нет в результате вложенного запроса. 
Отобранные записи добавляются в конец таблицы bookзапросом на добавление `INSERT`.

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Изменение значения в одном столбце

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. 
При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса `UPDATE`. Простейший запрос на  обновление выглядит так:

```sql
UPDATE таблица SET поле = выражение
```

где 
__таблица__ – имя таблицы, в которой будут проводиться изменения;
__поле__ – поле таблицы, в которое будет внесено изменение;
__выражение__ – выражение,  значение которого будет занесено в поле.

<hr>

*ПРИМЕР:*
*Уменьшить на 30% цену книг в таблице book.*

```sql
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Изменение значения в нескольких столбцах

Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно. 

В этом случае простейший запрос будет выглядеть так:

```sql
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

<hr>

*ПРИМЕР:*
*В столбце `buy` покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбце `buy` количество, а в столбец `buy` занести 0.*

```sql
UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 2      | 0   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 2      | 0   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | -3     | 0   |
+---------+-----------------------+------------------+--------+--------+-----+
```

Как видно из таблицы, без проверки данных, которые занесены в столбец, нельзя запускать запрос на обновление __(может получиться отрицательное значение количества)__.

<hr>

[:arrow_up:Оглавление](#Оглавление)

## Изменение данных, используя несколько таблиц

В запросах на обновление можно использовать несколько таблиц, но тогда

- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, `book.price` – столбец `price` из таблицы `book`, 
`supply.price` – столбец `price` из таблицы `supply`;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`;
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные.

<hr>

*ПРИМЕР:*
*Если в таблице `supply` есть те же книги, что и в таблице `book`, добавлять эти книги в таблицу `book` не имеет смысла. Необходимо увеличить их количество на значение столбца `amount` таблицы `supply`.*

```sql
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```
```sql
/* Результат: */
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```
<hr>

[:arrow_up:Оглавление](#Оглавление)

## Удаление записи из таблицы

Запросы корректировки данных позволяют удалить одну или несколько записей из таблицы.

Простейший запрос на удаление имеет вид:

```sql
DELETE FROM таблица;
```

Этот запрос удаляет все записи из указанной после FROM таблицы.

<hr>

*ПРИМЕР:*
*После того, как информация о книгах из таблицы `supply` перенесена в `book` , необходимо очистить таблицу `supply`.*

```sql
DELETE FROM supply;

SELECT * FROM supply;
```
```sql
/* Результат: */
Affected rows: 4
Affected rows: 0
```

Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.
<hr>

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова `WHERE`:

```sql
DELETE FROM таблица
WHERE условие;
```

[:arrow_up:Оглавление](#Оглавление)

## Создание таблицы на основе данных других таблиц

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

<hr>

*ПРИМЕР:*
*Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше 4. Для всех книг указать одинаковое количество экземпляров 5*

```sql
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```
```sql
/* Результат: */

```
<hr>

[:arrow_up:Оглавление](#Оглавление)
